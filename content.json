{"meta":{"title":"MybRose_blog","subtitle":null,"description":"这个人很懒，什么都没有写","author":"Mayubin","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于博主的那点事","date":"2018-11-21T00:52:58.000Z","updated":"2021-03-13T01:40:47.088Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"&emsp;我是马宇斌，本科在哈尔滨工业大学（威海）就读软件工程专业，研究生于哈尔滨工业大学（深圳）深造，在喜欢打篮球，唱歌。先这样，想好了再来写。。"},{"title":"分类","date":"2018-11-20T13:47:12.000Z","updated":"2018-11-21T00:56:37.075Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2018-11-21T00:49:51.000Z","updated":"2018-11-21T00:49:51.242Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-20T13:28:46.000Z","updated":"2018-11-21T00:55:23.986Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础","slug":"Java基础","date":"2021-03-11T03:13:00.000Z","updated":"2021-03-11T07:02:01.472Z","comments":true,"path":"2021/03/11/Java基础/","link":"","permalink":"http://yoursite.com/2021/03/11/Java基础/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"机器学习导论","slug":"机器学习导论","date":"2020-12-11T08:11:51.000Z","updated":"2021-03-13T01:51:40.746Z","comments":true,"path":"2020/12/11/机器学习导论/","link":"","permalink":"http://yoursite.com/2020/12/11/机器学习导论/","excerpt":"第一章 引言 第九章 遗传算法动机通过变异和重组当前已知最好的假设来生成后续的假设普及与发展：1.健壮性2.易于并行化3.假设的各个部分相互作用，每一个部分对总的假设适应度的影响难以建模","text":"第一章 引言 第九章 遗传算法动机通过变异和重组当前已知最好的假设来生成后续的假设普及与发展：1.健壮性2.易于并行化3.假设的各个部分相互作用，每一个部分对总的假设适应度的影响难以建模 遗传算法最佳假设被定义为使适应度最优的假设，适应度是为当前问题预先定义的数字度量如果学习任务是在给定一个未知函数的输入输出训练样例后逼近这个函数，那么适应度可以定义为假设在训练数据上的精度。如果是下国际象棋的策略，那么适应度是定义为该个体在当前群体和其他个体对弈的获胜率。算法迭代更新一个假设池，假设池称为一个群体。每一次迭代，根据适应度函数评估群体中的所有成员，然后从当前群体中用概率方法选取适应度最高的个体产生新一代群体。在这些被选中的个体中，一部分原样进入下一代群体，其他的被用作产生后代个体的基础。输入：排序候选假设的适应度函数，定义算法终止时适应度的阈值，要维持的群体的大小，决定如何产生后继群体的参数每一代群体中被淘汰的比例和变异率。基于当前的群体产生新一代的假设，首先，从当前的群体中选择一定数量的假设包含在下第一代中，这些假设是用概率方法选择的。 一个假设被选择的概率与他自己的适应度成正比，与当前群体中其他竞争假设的适应度成反比。产生新的一代PS 表示假设GA中假设经常被表示为二进制位串，便于变异和交叉遗传算子操作。 遗传算子交叉操作变异算子：用于对位串产生随机的小变化，方法是选取一个位，然后取反，通常在交叉之后进行。 适应度函数和假设选择举例遗传算法看作是通用的最优化方法，搜索一个巨大的候选对象空间，根据适应度函数查找表现最好的对象。Gabil 系统的实现1.表示每个假设对应于一个命题规则的析取集，规则前件的假设空间由一个固定的属性集的约束的合取组成","categories":[{"name":"ML","slug":"ML","permalink":"http://yoursite.com/categories/ML/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"自然语言处理","slug":"自然语言处理","date":"2020-12-10T11:34:32.000Z","updated":"2021-03-13T01:56:12.245Z","comments":true,"path":"2020/12/10/自然语言处理/","link":"","permalink":"http://yoursite.com/2020/12/10/自然语言处理/","excerpt":"第二讲如何表示单词的意义panda 上位词分布相似性：观察出现的上下文，并对上下文处理分布式分布式表示：密集型向量表示词汇的含义ont hot 什么是word2vec","text":"第二讲如何表示单词的意义panda 上位词分布相似性：观察出现的上下文，并对上下文处理分布式分布式表示：密集型向量表示词汇的含义ont hot 什么是word2vec Skip-grams","categories":[{"name":"ML","slug":"ML","permalink":"http://yoursite.com/categories/ML/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://yoursite.com/tags/nlp/"}]},{"title":"矩阵分析","slug":"矩阵分析","date":"2020-11-28T06:57:54.000Z","updated":"2021-03-13T01:56:53.225Z","comments":true,"path":"2020/11/28/矩阵分析/","link":"","permalink":"http://yoursite.com/2020/11/28/矩阵分析/","excerpt":"常考定义1.一般空间向量基的定义","text":"常考定义1.一般空间向量基的定义 2.线性映射的定义3.线性映射的矩阵表示的定义4.矩阵等价的定义5.不变子空间的定义6.矩阵相似的定义7.矩阵的行列式因子与不变因子8.矩阵的初等因子组9.内积的定义10.矩阵的正交三角分解定理11.什么是正规矩阵12.Schur定理是什么13.矩阵的奇异值分解14.什么是酉矩阵15.什么是λ矩阵的Smith标准型16.什么是λ矩阵的等价17.范数的定义18.p范数的定义19.Gram矩阵","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"矩阵分析","slug":"矩阵分析","permalink":"http://yoursite.com/tags/矩阵分析/"}]},{"title":"宇斌与煜","slug":"宇斌与煜","date":"2020-11-20T03:40:11.000Z","updated":"2021-03-13T02:05:38.172Z","comments":true,"path":"2020/11/20/宇斌与煜/","link":"","permalink":"http://yoursite.com/2020/11/20/宇斌与煜/","excerpt":"我们的故事开始于2020年十月四日那是国庆假期期间，连续在外面浪了两天的我，在休息了一天后，晚上找上舍友去球场想打会球。球场人好少，大家都回家了哈哈。我走向中间那个没人的场地，她从对面半场跑了过来，看到了我，然后走向另一个空场（hh我貌似抢了她原来投篮的场地，对面半场好像都是她的熟人）。瞟了一眼，惊讶了一秒，球场上竟然有女生，转头一想，可能国庆球场没人才来打球。她投了一颗球，（后来她说是第一球）就卡在篮脖子上了，我看到了，她尴尬的笑着望向我这边，貌似想寻求帮助，绅士的我hhh当然直接过去帮她把球放下来了。在那一刻，我发现她笑起来好好好好看。","text":"我们的故事开始于2020年十月四日那是国庆假期期间，连续在外面浪了两天的我，在休息了一天后，晚上找上舍友去球场想打会球。球场人好少，大家都回家了哈哈。我走向中间那个没人的场地，她从对面半场跑了过来，看到了我，然后走向另一个空场（hh我貌似抢了她原来投篮的场地，对面半场好像都是她的熟人）。瞟了一眼，惊讶了一秒，球场上竟然有女生，转头一想，可能国庆球场没人才来打球。她投了一颗球，（后来她说是第一球）就卡在篮脖子上了，我看到了，她尴尬的笑着望向我这边，貌似想寻求帮助，绅士的我hhh当然直接过去帮她把球放下来了。在那一刻，我发现她笑起来好好好好看。 我决定，去她那个半场投会球。犹豫再三，我开始找她聊天“同学，你是本科生吗？”“不是的呢，我是研究生。”“哦哦，我也是研究生，（有点惊喜，起初我认为她是大一新生呢），那你研几呢？”“那你应该叫我师姐。（有点奇怪，她认为的师姐可能是我认为的学姐的意思吧），我研二了。”“哦哦，那…师姐好，我研一。（我尴尬的笑着）”尬聊结束，我们接着投球，不一会，她的另一个小伙伴来了（后来知道是她舍友阿掰）。她离开了这个球场，回去找她的小伙伴了。我们的第一次相遇就这样在尬聊与投篮中结束了，我以为她也只会是我生命中的千万个过客中的一个而已，但是我错了。“今天打球那个女生挺好看诶”，我对龚梓（我舍友）说。“是啊，笑起来很甜。”“可惜怂了啊，没敢上去要微信。”“每天去球场蹲她呗，还能遇不到嘛。”“有道理。”我真的每天去球场蹲她了，但是貌似没那么幸运，她没有再在球场出现了。后来白天自习的时候，我想就这么点大的学校，还能找不到一个人吗。对哦，上表白墙找找试试。但是学校墙的点赞数与浏览数让我对表白墙找人没有抱有很大期待，果不其然，我的找人帖沉了。但我还是每晚会去打球。 再遇见再遇见她的时候，是十二天之后了，也是在篮球场。那晚打球的人很多，新场人满为患，一场突如其来的暴雨赶走了大部分人。我本来也准备离开了，师兄说，天气预报说只会下十分钟。我抱着无所谓的心理想“这天气预报有这么准吗，分钟都能预测到，哎，无所谓，回去也没事干，等会吧，万一停了呢。”确实我也是打得不够尽兴，因为那会才8点多，刚打没一会呢。过了几分钟，雨，真的停下来了。“天气预报挺准啊，地湿了，再投会吧，不打了。”张立才（他和我本科就在球队认识了，我们一块考来这边）说。“嗯。”我拿了一个球跑到另外一个空场，我想一个人练会，不想和他们瞎投。不一会儿，陆陆续续又有人来到球场了，但是远没有下雨前那么多人。一个女生的到来引起了我的注意。诶，那不是国庆打球遇到的学姐的小伙伴吗？那…等会她也会来吗？她空着手来的，她没拿球，我要不要借个球给她（我们当时有很多球）？几分钟后，她真的来了，丢下一颗球，然后又走了…“马宇斌，过来了，地干了（他们把地拖干了），正好六个人，再打会。”“好”看来大家都没有打得尽兴。但我有点心不在焉了，她怎么来了又走了啊，她小伙伴还在这呢，等会还会来吗？算了，先不想了，打会球先。打了不到半小时，又下起小雨了，这会老天只是把地板打湿然后就停了，大家开始抱怨起深圳的天气了，但我心思不在篮球上了。我早就注意到她在最边上的球场了。地板湿漉漉的总归不好打球，很容易受伤，她过来了，应该是想借个拖把吧。她在另一个场地等其他人使用拖把结束，她乖巧的在场边等着，带着笑容，还是那么好看。我扫了一下球场，在球场的最里面还有一个拖把，我走过去想给她拿过去，拿回来走到一半的时候她已经借到了，为了掩饰我帮她借拖把无果的尴尬局面，我只好把我们的球场拖了一遍。“诶，那个学姐来了。”这时龚梓也看到了。“是啊。”“去认识一下。”“嗯嗯，等会的。”说着等会的，内心还是很怂的，毕竟还没有过问其他人要过微信的经历。又过了一会，好像又有点微雨飘下，我们实在是没了兴致再接着打球了。“走吧。”“嗯，走吧走吧，天气太差了也。”“是啊，总是打湿一下就停了，今天不适宜打球。”大家吐槽着。我拿着球往回走，脚步越来越慢，哇，我在纠结什么，直接上去要不就好了，大不了被拒绝一次，总比事后一直后悔的好。但是第一次尝试总是最难的，我需要点外部刺激。“兄弟，那个女生就是我之前给你提过的。”我对张立才说道。“哪个呀。”“就那个。”我指了指她“走走走，过去要微信。”他拉着我的胳膊把我拽过去，我内心狂喜，我知道他会这么做。“我没拿手机。”“我拿了。”他打开了备忘录。“要不要我把球丢过去，你假装捡球，然后趁机创造机会。”一旁的龚梓半开玩笑道。“诺，手机给你，直接上。”他把手机递给我。我鼓起勇气走了过去，“你好，学姐。”，我打了个招呼，她犹豫了几秒可能在想我是谁，说道，“嘿，你好。”，应该是回忆起来了。刚准备开口直奔主题。“你们要和我们一块3打3吗。”子琪说道（她的另一个室友，中间时段过来的）情况有变，事情不应该是这样发展的！“好啊…”，我顺应着只能答应了。你们三狂笑，我的天，好尴尬，我把手上拿着的手机塞进口袋，粉色的手机壳实在太刺眼。我回头望向张，龚，用眼神请求帮助。你们打的正嗨，我们根本没法插手。简单的投篮过后，我也忘了我们有没有再说话，我只知道我得赶紧直奔主题了，拖着不是办法。“兄弟，手机锁了，你再帮我开一下。”我又一次鼓起勇气，向你走去。“学姐，我可以认识一下你吗，那个，我没拿手机，你可以写下联系方式吗？”我把手机递给了你。你尴尬的笑着，还是说道，“好啊…”，你写下自己的名字与电话的这两分钟里，仿佛时间都静止了，你的小伙伴也没有在打球，我拿着球像个木鱼一样站在那，只是望着你。“好了，给。”“嗯嗯，那学姐，我们先走了。”我指了指离开的方向。“好的”“拜拜，学姐。”“拜拜。”任务完成，赶紧溜，太尴尬了！回到宿舍，我加了她微信，哟，株洲的，还是个老乡嘿。至此，我和她的世界开始出现交集。 猜不透的想法“兄弟，她是我老乡诶，她株洲的。”我翻阅着她的朋友圈，嚯，这么多呢，还没有权限，哇，好漂亮，朋友圈的照片让我终于能仔细看到她的样貌，球场上总是不敢直视。“兄弟，怎么聊啊，教教我呗。”我问张立才，因为他的情感经历比较丰富。“你们老乡啊，聊点老家相关的。学姐也爱打球，聊点篮球也行。”“可以的，但不知道是不是单身？”“我问问我学长，我觉得应该没有对象吧，有的话就不会给微信了。”他有一个学长也是土木环境学院的。“可以”嗯…学姐啊，那么深圳应该都逛遍了吧，要不问问她十一去哪玩了，有啥好推荐的，嗯嗯，就这样。我向她推荐了我十一去的仙湖植物公园，给她看了我拍的两个世纪的菩提树，我们第一次的线上聊天在这就截止了，没有聊很多，但是自我感觉还不错哈哈。那晚，睡得好香。现在是上午十点，我在图书馆复习着上课内容，却始终有点心不在焉，我该怎么找她聊天呢，随便想个话题开头吧，感觉还是得线下见面才好啊。“学姐，你们导师给的任务多吗？”“你们实验室是信息楼吗？”“学姐你实验室几楼呢？”我扯着有的没的，她的回答让我觉得她好像还是对我有好感的，不会爱答不理的。不知不觉到了饭点，聊的起劲的我冲动地直接向她约饭了，却不想被拒绝了，瞬间后悔自己的做法，啊啊啊，我只有三次约她的机会，我怎么这么冲动的就浪费了一次，哎，冲动是魔鬼啊。“兄弟，那个学姐没对象的，我那个学长回我了。”这时，手机响了，是张立才。“哦哦，可以的。”我想他阐述了我现在的处境。“军师，我该怎么做呢。”我求助道。“别慌，兄弟，下午找个理由送奶茶吧，女生都爱喝奶茶。”“嗯..行，我试试。对了，你知道E栋是哪个楼吗？她实验室在E。”“就是我们开年纪大会的那个楼。”“哦哦，好。”我拿着两杯奶茶走在去她实验室的路上，心里十分忐忑，这是我第一次这么主动的想去认识了解一个人，我来到她实验室楼下，紧张地给她发消息问她是否有空，我好怕自己扑了个空。“学姐，你在实验室吗，你能下来一下吗？”“噢好”“你在哪呢？”“门口呢。”又等了一会，还是不见她，我开始意识到可能自己来错了教学楼“是理学楼这吗？😂”“哈哈哈哈我们在土木楼。”晕死，第一次送东西就去错了地方，中午约她吃饭被拒就已经很尴尬了，本想着帅气地给她送杯奶茶却不想来错了教学楼，我赶忙抓着奶茶就一顿狂跑。“啊哈哈哈，等我一下😂”我又不敢跑的太快害怕手中的奶茶洒出，我跑跑停停，不时的检查着。嗯，应该是这一栋楼，我抬头看着楼上印着大写的E，怎么没见到她呢，我一步步向里走去。快到门口了，我才瞥见了她的身影，她穿着一袭黑色长裙，戴着一副金丝边框眼镜，哇，好漂亮。我的心跳急剧加速。“学姐，我刚从外面玩回来顺便给你带了一杯奶茶。”我带着颤抖的声音说道，其实我是特意出去买的，我说了谎话，只是希望她不会拒绝我。“啊，好的，谢谢，下次不要再给我买奶茶了。”她尴尬的笑着接受了，“那…我上去了。”她好像迫不及待地想要离开，不愿意多留下和我聊哪怕一分钟。“额..好。拜拜学姐。”“拜拜。”球场外的第一次见面就这么草草了结。尴尬，反感，希望不要有下次送奶茶的行为了，不愿意和我多待哪怕一分钟，难过伤心，觉得自己没什么机会了。我拿着我自己那杯奶茶，背着沉重的电脑，想着是不是我中午草率地邀约吓到她了，我猛嘬一口奶茶，沿着大沙河走向图书馆，从未觉得这条路这么的长。 是偶遇吗？？才受挫一次，不至于吧，马宇斌 ，而且你想的有点多欸，你怎么知道她是怎么想的，别自顾自的自以为是了，再多了解了解再下结论啊。嗯！好，我给自己两周，这两周我就认真的去了解认识她，如果她真的对我不感冒，我就自动放弃。我自以为还不错的咨询着入党，社保卡相关的话题，她的回答显得是那么的耐心，我一个问题问过去，不一会儿，她发来一大段她详细的回答，我以为还不错的交流，殊不知在她看来只是姐姐对弟弟的关照。每日线上的聊谈总感觉不是那么得劲，我们都是研究生，每日学业课题的压力并没有让我们总能有那么多的闲暇时间。在一个周二，那时我连续在线上找了她四天，我多希望她也能主动找我一次，晚上的时候，我上着我这一天最后一节课，直到快下课的时候，我从书包拿出手机也没见到她的消息，哎，可能今天是等不到她的主动了，不想了，上了一天课，身心俱疲，打会球去。“下课🏀？”军师好像知道我的想法一样。“走！”回宿舍换了双球鞋，最近因为课程紧张，也有几天没碰球了，想着今晚得好好打一打。却不想到了球场却早已人满为患，我向里面场地瞟去，最里面的场地有几个女生在那。“那是学姐吗？”张问我。“不知道啊，看不清。”我拍着球向里走，“好像是的。”我确定就是她了，熟悉的笑容，像融化冰川的暖阳，照射到我的内心，心跳加速，我加快了脚步，走到她面前打了声招呼。我们寒暄了几句。原本在球场上投篮的她，来到场边座椅喝了口水便站在那了。咦，她是在等我过去吗，哇，机会，过去聊会吧。我借着线上没聊明白的话题接着问她，她的回答与笑容让我觉得她并没有像线上的冰凉的回复那样看待我，她对我貌似还是有好感的。我们聊了大概十几分钟，话题枯竭，又进入了一种尴尬氛围。“去打会吗？”我指了指球场，她的小伙伴在场上投的甚欢。我把军师拉来，“等会帮我演一演。”“懂的。”只是场边还有不少不认识的同学觊觎着这个半场，我走了过去，“同学，我们土木环境学院课题组今天团建，你们…”“嗷嗷，好。”撒了个慌，不希望被他们破坏好不容易组成的局。大家都很默契的让我和她分在了一边，那晚我的注意全都被她给带走了，我想把每颗球都喂给她，眼神一直在她身上没法挪开。我和军师互相演戏，以至于后来我才知道军师被他的队友给嫌弃了。愉快的时光总是短暂的，不知不觉也已到了十点，球场马上要熄灯了，望着她虽然疲倦却满脸笑容，我也早已散去白天的疲乏，只剩下快溢出的喜悦。“怎么样，演的不错吧。”“哈哈哈，不错，可以的。” 红配绿，还挺搭时间过得飞快，看了一眼时间，12点14分，我起身离开图书馆，习惯性的骑车前往北大，可那一瞬间，我不自觉地调转了车头来了个180度大转弯。“马老师，你演我呢。”龚老师可能被晃到了。”去清华吧，好久没去了。”我虽在图书馆学习，却很少去哈工大和清华食堂吃饭，一来工大的学生确实太多，不乐意排队的我不愿和本科生们”抢饭”，一来骑车前往清华的路途总是很多车辆，虽路途不远却也不愿吸汽车尾气。但那天，我想说不定可以遇到她呢，我记得她曾说过，她偶尔做完实验也会去清华吃饭，我却不抱什么期待，毕竟都已经12点半了，这个点她应该早就吃过了。停好了车，我们径直走向清华一食堂，在门口却有一个穿着绿色卫衣的女生经过，好熟悉的身影，我目不转睛地看着她，她只是低着头玩着手机，脸上藏不住的笑容，心情一定很不错。“学姐。”我叫住了她。“嗨..”她可能也觉得很巧合。我向龚老师使了个眼色，","categories":[],"tags":[{"name":"❤","slug":"❤","permalink":"http://yoursite.com/tags/❤/"}]},{"title":"游戏化思维","slug":"游戏化思维","date":"2020-11-19T00:43:23.000Z","updated":"2021-03-13T01:53:02.077Z","comments":true,"path":"2020/11/19/游戏化思维/","link":"","permalink":"http://yoursite.com/2020/11/19/游戏化思维/","excerpt":"Game and gamificationWhat is game?The game is not the experience.The game enables the experience but it is not the experience.","text":"Game and gamificationWhat is game?The game is not the experience.The game enables the experience but it is not the experience. What is gamification?Gamification is broadly defined as using those same elments that comprise so-called game, making games fun and motivating users in a non-game context to inluence behavior. From game to gamificationThe essence of games is not entertainment, it is a fusion of human nature and skillful design.Game designu and the principle of human nature 3 perspectives to understand gamification value1.Engagement: motivate people to do things2.Experimentation: open up the space of possibility3.Results:oppositive outcomes 3 perspectives to understand the concept of gamification designUsing game elements in non-game contexts1.Game elements:A toolkit for building a gameObjects,relationships among objects ,abstract concepts embedding rules…2.Game-design techniques:How to make the overall gamified experience greater than the sum of these parts?Points,badges,leaderboards3.Non-game contexts Internal , External and Behavioral change Internal gamification:Improve productivity within the organization in order to foster innvoation ,enhance camaraderie or derive positive results through their own employees.External gamification:Enhance your customers or prospective customers.Involves your customers or prospective customers,generally driven by marketing objectives.objectives include:a)improve the relationship between businesses and customersb)produce increased engagement,identification with the productc)stronger loyaltyd)ultimately higher revenuesBahavior change gamification:Seeks to form beneficial new habits among a population.It seeks to form beneficial new habits among a population to produce desirable societal outcomes. Can gamification fix all the problems?1.Motivation:从鼓励行为中获取价值123453 applicable activitiesa) creative work:当人们深入的关注自己所有的东西，工作的会很好b) Mundane tasksc) Behavior changeEmotional connections ,unique skills ,creativity and teamwork 2.Meaningful choices:3.Structure:points, badges,leaderboards4.Potential conflicts:depend on motivation ,offer interesting challenges that are easily coded into rules,and reinforce existing reward systems Game thinkingGame thinkingis the mind set required to deploy fun in a considered and directed way.Extrinsic motivationIntrinsic motivation:1.Competence/mastery, means being effective in dealing with the external environment(Todolist 清单的完成)2.Relatedness involves social connection and interaction and the universal desire to interact with and be involved with family, friends, and others.(与朋友之间的联系，社交)3.Autonomy suggests the innate need to feel in command of one’s life and to be doing that which is meaningful and in harmony with one’s values.(感觉自己被需要) The 8 core drives of gamification1.Epic meaning &amp; Calling2.Development &amp; Accomplishment3.Empowerment of Creativity &amp; Feedback4.Ownership &amp; Possession5.Socical influence &amp; Relatedness6.Scarcity &amp; impatience7.Unpredictability &amp; Curiosity8.Loss &amp; Avoidance The game elementsPoints ,badges and leaderboard The DMC -dynamics, mechanics,and components1234567891011121314151617181920212223Dynamic:Big picture aspects of the gamified system that you have to consider and manage.1.Constarints2.Emotions3.Narrative4.Progression5.RelationshipMechanics:(结构，机器学)Basic processes that drive the action forward and generate player engagement.(推动玩家行为向前)1.Challenges2.Chance3.Competition4.Cooperation5.Feedback6.RewardsComponents:More specific forms that mechanics or dynamics can take.1.Achievements2.Avatars3.Badges4.Fights5.Collections6.Combat Six steps to design gamificationA good design process melds creativity and structure to match people’s needs with technical feasibility and business realities.1.Define objectivesList objectives=&gt;Rank objectives and trade off goals=&gt;Delete machnics or the means to an end=&gt;Jusitify objectives2.Delineate target behaviorsTarget behaviors should be concrete and specific:• Sign up for an account on your website• Post a comment on a discussion board• Exercise for at least 30 minutes• Share information about your service on Twitter• Comment or vote on suggestions by others.The behaviors you are looking for should promote theultimate business objectives you previously defined,though the relationship may be indirect.3.Define your playersKillers ,Achievers,Socializers and Explorers.Mind the fact that your players are growing up.4.Devise activity cycles• Engagement loops:At a micro level, what your players do, why they doit, and what the system does in response.• Progression stairs:Give a macro perspective on the player’s journey.(提供宏观视角)5.Dont forget the fun6.Deploy the appropriate toolsYouneed a team:• People who understand the business goals of the project• An understanding of your target group of players and the basics ofpsychology,• Game designers• Analytics experts able to make sense of the data your gamified systemsgenerates• Technologists able to implement your vision.","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"游戏化思维","slug":"游戏化思维","permalink":"http://yoursite.com/tags/游戏化思维/"}]},{"title":"现代密码学","slug":"现代密码学","date":"2020-11-07T01:00:35.000Z","updated":"2021-03-13T01:55:09.202Z","comments":true,"path":"2020/11/07/现代密码学/","link":"","permalink":"http://yoursite.com/2020/11/07/现代密码学/","excerpt":"整体框架密码学分类1.经典密码学，包含了隐写，替换与转移，其中替换包含了凯撒加密，维吉尼亚加密，希尔加密，转移包含了围栏形式2.现代密码学，包含了对称加密以及非对称加密，其中对称加密分为块加密（DES,AES），流加密(RC4)，以及消息认证(MAC，Hash)，非对称加密包含了公钥加密(RSA,ELGamal签名)","text":"整体框架密码学分类1.经典密码学，包含了隐写，替换与转移，其中替换包含了凯撒加密，维吉尼亚加密，希尔加密，转移包含了围栏形式2.现代密码学，包含了对称加密以及非对称加密，其中对称加密分为块加密（DES,AES），流加密(RC4)，以及消息认证(MAC，Hash)，非对称加密包含了公钥加密(RSA,ELGamal签名) 经典密码学1.凯撒加密：向后移动三位的形式（单字母单表）2.多表置换加密3.维吉尼亚加密：有一个密钥流，实现单字母多表形式4.Playfair 加密：密钥产生为一个55矩阵，相同列向下移动，相同行向右移动，非行非列则该字母相同行，另一个字母的列5.希尔加密：通过一个33的矩阵的形式进行加密6.围栏加密：就是相当于卷轴的形式，上下写然后横着读出成密文7.列置换加密：首先将明文按照矩阵的形式行到列的形式排列下来，然后每一列随机确定一个顺序，读的时候按照列顺序读形成密文8.轮转加密形式：轮转加密机器实现 密码攻击类型1.COA：仅知道密文以及加密算法的攻击，除了密文啥也不知道2.KPA：知道加密算法，知道一对或者多对的明文密文对3.CPA：选择明文攻击，攻击者可以选择自己指定的明文进行攻击4.CCA：选择密文攻击，攻击者选择密文，然后得到相应的明文 一次一密（OTP）在信息传递的过程中，双方的密钥是随机变换的，每次通信双方都使用同一条临时随机密钥和对称加密算法进行加密 现代密码学三原则，私钥加密的安全性定义–完美安全加密三原则1.形式化安全定义2.精确假设3.安全性证明：假设成立然后退出加密算法是安全的 Threat model and Break model1.COA,KPA,CPA,CCA2.Break model：① 攻击者不能获取完整的明文（太弱了） ② 攻击者不能计算出明文的任何字母（太弱了） ③ 攻击者对明文一点都不知道（太强了定义）④ 攻击者不能得到明文的新消息","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"现代密码学","slug":"现代密码学","permalink":"http://yoursite.com/tags/现代密码学/"}]},{"title":"智能证券投资学","slug":"智能证券投资学","date":"2020-09-07T11:00:17.000Z","updated":"2021-03-13T01:55:05.041Z","comments":true,"path":"2020/09/07/智能证券投资学/","link":"","permalink":"http://yoursite.com/2020/09/07/智能证券投资学/","excerpt":"第一章定义以及要点提高人理性投资效率的学问要点：理性投资，自动化提高效率，个性化","text":"第一章定义以及要点提高人理性投资效率的学问要点：理性投资，自动化提高效率，个性化 个性投资自动化从人的角度出发，研究个人理性投资逐步向自动化发展1.归纳出人的理性投资的科学方法2.自顶向下逐步分解细化为多个人工任务3.开发自动系统代替人工任务宏观判势，具体实施，以史为鉴，悟道出师 自动投资人性化从自动系统的角度，研究自动化由易到难逐步发展适应不同的人的理性选择1.将人的需求由易到难构建自动投资层次体系2.建立自动投资智能体3.逐步完善理性智能投资系统供不同的用户理性使用理性智能投资系统：SADI-5L-MT一。自动证券投资的层次结构ASI5L信息量化–个性归纳–自动投资推荐–受控自动投资–完全自动投资二。自动投资智能体结构SADI感知量化–任务执行–评测归因–学习进化","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"智能证券投资学","slug":"智能证券投资学","permalink":"http://yoursite.com/tags/智能证券投资学/"}]},{"title":"机器学习","slug":"机器学习","date":"2020-09-05T10:59:38.000Z","updated":"2021-03-13T01:55:14.894Z","comments":true,"path":"2020/09/05/机器学习/","link":"","permalink":"http://yoursite.com/2020/09/05/机器学习/","excerpt":"监督与非监督学习ovtave matlab 线性回归问题递归下降线性回归的递归下降多功能多元梯度下降法","text":"监督与非监督学习ovtave matlab 线性回归问题递归下降线性回归的递归下降多功能多元梯度下降法 多元递归下降法之特征缩放尽量把特征值缩放在-1到1之间。均值归一化，xi-ui使得平均数为0，然后再进行特征缩放在-1到1 多元梯度下降法之学习率α选择适当的学习率，一般是0.001，然后翻三倍或者翻十倍的方法进行取值的方式太大容易错过最低点，太小递归速度太慢 特征与多项式回归正规方程 逻辑回归分类算法 sigmoid函数 决策界限进行分类的那个界限 代价函数简化代价函数与梯度下降 高级优化多元分类，一对多将其他的类型设置为负类，得到训练集，然后输入一个x，去进行预测的时候，计算出每个预测结果，最大的那个数值就是x属于的类别 过拟合问题1.减少选取变量的数量，找到重要的变量不重2要的舍去–模型选择方法2.正则化，将保留所有变量，但是要减少量级。 正则化–代价函数参数值小意味着得到一个更加简单的假设模型。λ表示惩罚项，惩罚项越大表示被惩罚的那个θ的值应该越小 线性回归的正则化梯度下降法的正则化 正规方程的正则化 逻辑回归的正则化梯度下降算法的正则化和线性回归当中的递归下降正则化很像高级优化算法的正则化 非线性假设神经网络 神经网络的代价函数n表示有多少个影响因素，m表示在逻辑回归中可以分为多少个类，sl表示在每一层的元素的个数，从输入层到隐藏层到输出层，θ其实是一个向量矩阵 反向传播算法第一步随机初始化权重值，第二步用向前传播的方法计算出hθ(x^i)，第三步用代码计算出代价函数，第四步用反向传播的方法计算偏导数，第五步使用梯度检查，比较反向传播得到的偏导数和用数值方法得到的估计值，然后停止梯度检查，最后一步使用梯度下降或者一些高级优化算法最小化代价函数 模型选择，训练、验证和测试集用交叉验证集来进行测试，获取合适的degree 偏差和方差高偏差：训练误差和验证误差都很大（欠拟合)高方差：训练误差很大验证误差不大（过拟合） 正则化和方差偏差λ如果非常大表示的是欠拟合，λ如果非常小表示的是过拟合 学习曲线高方差：采用使用更多的训练集，使用更少的特征，增加λ，欠拟合，每个特征趋近与0高偏差（容易走偏）：采用更多的特征，减少λ，过拟合，每个特征趋近自己的值 决定执行的优先级误差分析不对称分类的误差评估精准度和召回率的权衡精度 = 真正例/（真正例+假正例）：在所有判为恐怖分子中，真正的恐怖分子的比例召回率= 真正例/（真正例+假反例）：正确判为恐怖分子占实际所有的恐怖分子的比例像癌症这种情况，我们希望不漏掉任何一个可能出现的患者，所有召回率比较高 机器学习数据支持向量机优化目标从逻辑回归当中进行改进得到的，支持向量机也叫做大间隔分类器 大间隔分类器的数学原理 硬间隔对偶关系 核函数 聚类算法k-means算法：随机初始化，k太大的话多次随机初始化的效果就不太好 选取聚类数量数据压缩（降维）可视化主成分分析问题pca 选择k值","categories":[{"name":"ML","slug":"ML","permalink":"http://yoursite.com/categories/ML/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"算法设计与分析之回溯与分支界限算法","slug":"算法设计与分析之回溯算法","date":"2020-03-15T01:09:26.000Z","updated":"2021-03-13T01:55:10.252Z","comments":true,"path":"2020/03/15/算法设计与分析之回溯算法/","link":"","permalink":"http://yoursite.com/2020/03/15/算法设计与分析之回溯算法/","excerpt":"回溯算法基本思想12345671.适用：求解搜索问题和优化问题2.搜索空间：树，结点对应部分解向量，可行解在树叶上3.搜索过程：采用系统的方法隐含的遍历搜索树4.搜索策略：深度优先，宽度优先，函数优先，宽深结合5.结点分支判定条件：满足约束条件，分支扩张解向量，不满足约束条件，回溯到该结点的父节点6.结点状态：动态生成，分为白色黑色灰色结点7.存储：当前路径","text":"回溯算法基本思想12345671.适用：求解搜索问题和优化问题2.搜索空间：树，结点对应部分解向量，可行解在树叶上3.搜索过程：采用系统的方法隐含的遍历搜索树4.搜索策略：深度优先，宽度优先，函数优先，宽深结合5.结点分支判定条件：满足约束条件，分支扩张解向量，不满足约束条件，回溯到该结点的父节点6.结点状态：动态生成，分为白色黑色灰色结点7.存储：当前路径 适用条件：多米诺性质：符合k+1的解同样符合k的解的性质，以及逆否命题的成立 回溯算法的实现递归实现与迭代实现 例子：4后问题问题：在4*4的方格棋盘上放置皇后，使得没有两个在同一行，同一列，对角线 例子:0-1背包问题问题：有n种物品，每种只有一个，第i种物品价值为vi，重量为wi，如何选择使得总重量不超过B，而价值达到最大回溯算法或者贪心算法都可以，并且类似于最小装载问题 例子:货郎问题问题：有n个城市，已知任两个城市之间的距离，求一条每个城市都经过一次的回路，使得总长度最小搜索空间：排列树，有（n-1）!片树叶 例子：装载问题问题：与之前的装载问题不同，这里有两艘轮船，载重分别为c1和c2，所有的集装箱的重量和小于c1+c2，求合理的方案，所有的箱子都上船算法思想：令第一艘船的装入量为w11.用回溯算法使得c1-w1达到最小的装载方案2.然后判断剩下的总重量是否满足第二艘船每一层的选择都有两个，所以时间复杂度为O(2^n) 例子：图的着色问题：无向连通图G与m种颜色的集合，用这些颜色给图的顶点着色，每个顶点一种颜色，要求每条边的两个顶点的颜色不同约束条件：顶点k+1的邻接表中结点用过的颜色不能再用，如果邻接表结点用过m种，则结点k+1没法着色，从该节点回溯到父节点，满足多米诺性质搜索策略：深度优先时间复杂度：O(nm^n)时间复杂度与改进途径:根据对称性，只需要搜索1/3的解空间 搜索树结点的估计Monte Carlo方法1231.从根开始，随机选择一条路径，直到不能分支为止2.假定搜索树的其他的分支与以上随机选出的路径一样，计数搜索树的点数3.重复1，2，将结点数进行概率平均 例如对于四后问题的搜索树采用Monte Carlo方法进行估计剩下的没有给出图示，进行多次抽样，每次给出的计算平均节点数 分支界限及其应用最大团问题最大团：顶点数最多的团，团中包含的顶点是一个完全图问题：给定无向图，求最大团蛮力算法：对每个顶点子集，检查是否构成团，检查每对顶点之间是否有边，有2^n个子集分支界限：","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/tags/算法设计与分析/"}]},{"title":" 算法设计与分析之贪心算法","slug":"算法设计与分析之贪心算法","date":"2020-03-13T02:07:36.000Z","updated":"2021-03-13T01:55:09.772Z","comments":true,"path":"2020/03/13/算法设计与分析之贪心算法/","link":"","permalink":"http://yoursite.com/2020/03/13/算法设计与分析之贪心算法/","excerpt":"贪心算法123456贪心法适用于组合优化问题，必须进行正确性证明证明贪心法不正确的方法有举反例贪心法常常采用数学归纳法进行证明归纳步骤大多是从n推向n+1，经常使用反证法去排除错误延迟调度问题：采用的是从一个优化解一步步转换得到最终的算法解的方法，需要证明转换步骤有限，转换后的优化性质不变零钱问题给出了一个定理用参数估计分析","text":"贪心算法123456贪心法适用于组合优化问题，必须进行正确性证明证明贪心法不正确的方法有举反例贪心法常常采用数学归纳法进行证明归纳步骤大多是从n推向n+1，经常使用反证法去排除错误延迟调度问题：采用的是从一个优化解一步步转换得到最终的算法解的方法，需要证明转换步骤有限，转换后的优化性质不变零钱问题给出了一个定理用参数估计分析 活动选择问题问题：输入为n个活动每个活动具有开始时间与结束时间，定义活动相容为一个活动的开始在另一个活动结束之后贪心策略：1.挑选开始时间最早的从前向后挑选2.挑选占用时间最少的活动优先3.挑选结束时间早的优先其中策略1和2都具有反例证明不正确只有策略3是正确的贪心法正确性证明：通常采用数学归纳法，分为第一与第二数学归纳法 活动选择算法的命题命题：算法执行到第k步，选择k项活动，则存在最优解A包含这些选择的k个活动。 算法前k步的选择都将导致最优解，至多到n步得到问题的最优解 归纳基础基础：k=1，证明存在最优解包含活动1证明：反证法不难知道 归纳步骤假设命题对k为真，证明对k+1也为真1注意A只是包含了i1到ik还有可能包含其他的，而那些在待选集当中，待选集是与已经选择的相容的，这是个子问题所以那个B一定是子问题的最优解 最小装载问题问题：n个集装箱，每个重量为wi，如何使得装的箱子最多，限制条件为装载重量限制0-1背包比较：集装箱为物品，物品重量为wi关键是价值都为1 贪心算法策略：轻者优先 贪心命题命题：对装载问题的任何规模为n的输入实例，算法得到最优解 归纳基础证明对只含有一个箱子的输入实例，贪心法显然正确 归纳步骤12这个的证明思路是反过来的，由n+1去掉箱子1然后由归纳法得到n个箱子的优化解，然后再加上第一个箱子，证明加上后也是优化解主要的思路还是反证法：若不是则去找到一个比原来解大的，然后去掉第一个，发现n个箱子的优化解出现了矛盾 最小延迟调度问题问题：客户集合A，ti为服务时间，di为要求完成时间，一个调度f:A-&gt;N,f(i)为客户i的开始时间，求最大的延迟达到最小的调度 贪心策略1.按照每个客户需要的服务时间ti从小到大安排2.按照di-ti从小到大安排（最着急截至的安排）3.按照di从小到大安排反例1：t1=1,d1=100,t2=10,d2=10反例2：t1=1,d1=2,t2=10,d2=10 交换论证：正确性证明（di命题）逆序：一个活动的开始时间在前，但是这个活动的截至时间di在后引理1：没有逆序没有空闲时间的调度有相同最大延迟操作步数有限，最多为n(n-1)/2上述的证明实在引理1成立的条件下证明的 12这个问题的解法与之前的又有所不同，这里是通过对于一般最优解与算法解之间的区别分析，设计得到转换操作使得，使得每一步转换不降低解的最优性质，但是逐步的向算法解趋近需要证明操作步数有限，证明每步操作的解仍然最优 得不到最优解的处理办法1.输入参数分析2.误差分析：估计贪心法，近似算法所得到的解与最优解的误差 找零钱问题问题:有n种零钱，每种的重量为wi，价值为vi，需要付钱为y，如何付钱使得付钱总重量最轻 动态规划 贪心法 定理（没有证明过程） 实例1找零钱的问题用的是参数化分析的方法，估计误差的方法没有给出 哈夫曼树","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/tags/算法设计与分析/"}]},{"title":"C语言之往年试题","slug":"C语言之往年试题","date":"2020-03-12T02:43:18.000Z","updated":"2021-03-13T01:56:05.945Z","comments":true,"path":"2020/03/12/C语言之往年试题/","link":"","permalink":"http://yoursite.com/2020/03/12/C语言之往年试题/","excerpt":"数组指针和指针数组12首先判断上面那个是一个数组，然后是个指针类型的，所以是指针数组下面的首先是个指针，然后是个数组，所以是一个指向int数组的数组指针 1一个指针相加一个常数，使用这个指针所指向的类型的所占内存大小乘以常数然后相加","text":"数组指针和指针数组12首先判断上面那个是一个数组，然后是个指针类型的，所以是指针数组下面的首先是个指针，然后是个数组，所以是一个指向int数组的数组指针 1一个指针相加一个常数，使用这个指针所指向的类型的所占内存大小乘以常数然后相加 排序算法冒泡排序12345678910111213141516171819202122232425for(i=0;i&lt;n&amp;&amp;find;i++) &#123; find=0; for(j=n-1;j&gt;i;j--)//这里的结束条件在i后面一位，所以下面的判断语句是要减去1 &#123; if(a[j-1]&gt; a[j]) &#123; find=1; int temp =a[j-1]; a[j-1] =a[j]; a[j] =temp; &#125; &#125; &#125; for(i=0;i&lt;n&amp;&amp;find;i++) &#123; find=0; for(j=0;j&lt;n-1-i;j++)//这里的结束条件是在i的前面一位，所以判断语句要加上1 &#123; if(a[j]&gt;a[j+1]) &#123; find=1; &#125; &#125; &#125; 选择排序123456789101112131415161718192021222324252627for (i=0; i&lt;n-1; i++)//每次把最小的放在某一个位置上 &#123; for (j=i+1; j&lt;n; j++) &#123; if (strcmp(ptr[j], ptr[i])&lt; 0) &#123; temp = ptr[i]; ptr[i] = ptr[j]; ptr[j] = temp; &#125; &#125; &#125;for(i=0;i&lt;n;i++) &#123; int min=i;//每次的这个位置假设是最小的 for(j =i+1;j&lt;n;j++) &#123; if(a[j]&lt;a[min]) min=j; &#125; if(min!=i)//相比于上面那个优化的步骤在这可能不用交换 &#123; int temp =a[i]; a[i]=a[min]; a[min]=temp; &#125; &#125; 归并排序123456789101112131415161718192021222324void Merge(int a[], int b[], int c[], int m, int n)&#123; int i=0,j=0; int index=0; while(i&lt;m &amp;&amp; j &lt;n) &#123; if(a[i] &gt;b[j]) &#123; c[index++] =a[i++]; &#125; else &#123; c[index++] =b[j++]; &#125; &#125; while(i&lt;m) &#123; c[index++] =a[i++]; &#125; while(j&lt;n) &#123; c[index++] =b[j++]; &#125;&#125; 插入排序123456789101112131415161718192021222324252627for(i=n-1;i&gt;=0;i--)//这一题是单次插入 &#123; if(a[i]&gt;x) &#123; a[i+1]=a[i]; &#125; else &#123; a[i+1]=x;//这里在比较的过程中减去了1所以应该再加回来 break; &#125; &#125;void InsertSort(int a[],int n)&#123; int i ,j,temp; for(i=1;i&lt;n;i++) &#123; temp = a[i];//从第二个数开始向前面的数组插入 j=i-1; while(j&gt;=0 &amp;&amp;a[j]&gt;temp) &#123; a[j+1] =a[j]; j--; &#125; a[j+1]=temp;//这里因为比较的过程中向前移动了以为所以要加个一 &#125;&#125; 快速排序12345678910111213141516171819202122232425int Partition(int a[],int low,int high)//一次划分可以把所有小于标准值的数放在左边，所有大于标准值的数放在右边&#123; int pivot= a[low]; while(low&lt;high) &#123; while(low&lt;high&amp;&amp; a[high]&gt;=pivot) high--; swap(&amp;a[low],&amp;a[high]); while(low&lt;high &amp;&amp; a[low]&lt;=pivot) low++; swap(&amp;a[low],&amp;a[high]); &#125; a[low]=pivot; return low;&#125;void QuikSort(int a[],int low,int high)//递归实现多次划分&#123; if(low&lt;high) &#123; int temp = Partition(a,low,high); QuikSort(a,low,temp-1); QuikSort(a,temp+1,high); &#125;&#125; 堆排序1234567891011121314151617181920212223242526272829303132void HeapAdjust12(int a[],int begin,int end)&#123; int temp=a[begin]; int i ; for(i=2*begin;i&lt;=end;i=i*2) &#123; if(a[i]&lt;a[i+1] &amp;&amp;i&lt;end) &#123; i++; &#125; if(temp&gt;a[i])//这里确定了是采用大根堆的形式，因为如果比较大就直接跳过了 break; a[begin] =a[i]; begin = i; &#125; a[begin] = temp;&#125;void HeapSort2(int a[],int n )&#123; int i; for(i=n/2;i&gt;0;i--) &#123; HeapAdjust12(a,i,n);//初始化为大顶堆 &#125; for(i=n;i&gt;0;i--) &#123; int temp=a[1]; a[1]=a[i]; a[i]=temp;//将最大的元素放在最后一个 交换下来 HeapAdjust12(a,1,i-1); &#125;&#125; 往年试题大数阶乘问题思想：关键是要设置一个进位变量carry123456789101112131415161718192021222324252627282930313233343536373839方法一：for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;index;j++) &#123; int temp =(a[j]*(i+1)+carry);//这里的相乘一定是i+1，因为这里存储的下标是从0 开始的，同样打印语句中答应的下标要从index-1开始 a[j]= temp%10 ; carry = temp /10; &#125; while(carry) &#123; a[index] = carry%10; carry=carry/10; index++; &#125; &#125;程序改错方法二：for (i = 1; i &lt;= m; i++) &#123; for (j = 1; j &lt;= index; j++) &#123; data[j] = data[j] * i; &#125;//其实思想是一样的这里是全部先乘完之后然后再去做进位运算 for (k = 1; k &lt; index; k++) &#123; if (data[k] &gt;= 10) &#123; data[k + 1] = data[k + 1] + data[k] / 10; data[k] = data[k] % 10; &#125; &#125; while (data[index] &gt;= 10 &amp;&amp; index &lt;= SIZE - 1) &#123; data[index+1] = data[index] / 10 + data[index+1]; data[index] = data[index] %10; index ++; &#125; &#125; 试题：将句子拆成单词1234567891011121314int i=0,j=0,k=0; while(i&lt;len) &#123; k=0;//每次都要初始化，然后赋值给下一个字符串 while(a[i]!=' ' &amp;&amp;i&lt;len) &#123; ss[j][k]=a[i]; k++; i++; &#125; ss[j][k] ='\\0'; j++; i++; &#125;","categories":[{"name":"复试","slug":"复试","permalink":"http://yoursite.com/categories/复试/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"算法设计与分析之动态规划","slug":"算法设计与分析之动态规划","date":"2020-03-11T02:58:56.000Z","updated":"2021-03-13T01:55:11.013Z","comments":true,"path":"2020/03/11/算法设计与分析之动态规划/","link":"","permalink":"http://yoursite.com/2020/03/11/算法设计与分析之动态规划/","excerpt":"动态规划例子：最短路径问题输入：起点集合与终点集合。输出：一条从起始到终点的最短路径蛮力算法：考察每一条，如果网络的层数为k则路径条数接近2^k动态规划算法：多阶段决策过程，每步求解的问题是后面阶段求解问题的子问题，每一步依赖于前步骤的决策结果 优化原则：最优子结构性质12优化函数的特点：任何最短路的子路径相对于子问题始终点最短优化原则：一个最优决策的任何子序列本身也是相对于子序列的最优决策序列","text":"动态规划例子：最短路径问题输入：起点集合与终点集合。输出：一条从起始到终点的最短路径蛮力算法：考察每一条，如果网络的层数为k则路径条数接近2^k动态规划算法：多阶段决策过程，每步求解的问题是后面阶段求解问题的子问题，每一步依赖于前步骤的决策结果 优化原则：最优子结构性质12优化函数的特点：任何最短路的子路径相对于子问题始终点最短优化原则：一个最优决策的任何子序列本身也是相对于子序列的最优决策序列 例子：矩阵链相乘问题：Ai为Pi-1xPi阶矩阵，确定乘法顺序，使得元素相乘的总次数最少输入：n个矩阵的行数与列数以向量形式给出输出：矩阵链乘法加上括号的位置分析：基本运算次数，计算每个元素的总计乘法次数为ijk算法分析1.蛮力算法加上n个括号的方法有卡特兰数级别的方法数，是一个指数级别2.动态规划算法子问题划分：设置最好的划分的运算次数：m[i,j]子问题的依赖关系：最优划分最后一次相乘发生在矩阵k的位置优化函数的递推方程： 动态规划算法的递归实现12时间复杂度分析：通过数学归纳法容易证明T(n)&gt;=2^(n-1)递归实现效率不高，多个子问题重复计算 动态规划算法的迭代实现12对于矩阵相乘算法的子问题的分析：长度为x的子问题有n-x个时间复杂度分析：需要构建备忘录与标记函数。O(n^3) 两种方法的比较：迭代算法的时间复杂度比递归的小，但是消耗空间动态规划时间复杂度：备忘录各项计算量之和加上追踪解工作量动态规划的要素：1.划分子问题2.定义优化函数，确定是否满足最优子结构3.列出递推方程和边界条件4.设计备忘录5.考虑是否使用标记函数6.计算时间复杂度 例子：投资问题问题：m元钱，n项投资项目，函数fi（x）表示将x投入第i个项目的效益，求使得总的效益最大的投资方案建模：目标函数是f1(x1)+···+fn(xn)的最大值。约束条件是所有的x相加为m子问题的界定与计算顺序：由参数k与x界定，k为考虑对项目1到k的投资，x表示投资的总钱数不超过x优化函数的递推方程：Fk(x)：x元投资给前k个项目的最大收益备忘录和解其中表格第二个数据表示的是投资给这个项目的钱数时间复杂度分析：备忘录中有m行n列，一共mn项，xk的取值有x+1种取法，计算Fk(x)项需要x+1次加法与x次比较，加法与比较的所有项求和得到w(n) =O(nm^2) 例子：背包问题问题：可以放入背包的物品有n种，每种物体的重量和价值为wi与vi，背包的最大重量限制为b，怎么样选择使得价值最大 建模：目标函数为求价值乘以个数的之和的最大值，约束条件为个数乘以重量求和的不超过b子问题界定与计算顺序：由参数k与y界定，k表示对于物品1到k的选择，y表示的是总重量不超过y。优化函数的递推方程：1234对比：相比较与投资问题，这里的b为钱数m，投资项目为物品种数效益相当于价值关键在于背包问题中有一个每一个物品都有一个重量这个条件在约束所以如上图所示，递归方程其实是一样的，只是写法不同而已。第一种的递推方程是一次只减少一个最后一个物品的重量，依次可以递推下去得到优化解 标记函数：通过最大标号可以得出最大物品至少装了一件或者哪些没装实例追踪解：通过标记函数得到的最大物品，然后减去这个最大物品的重量迭代下去就可以得到每个物品的重量，然后可以得到价值时间复杂度分析：备忘录的计算需要nb项，每项常数时间O(nb)背包问题的推广：1.0-1背包，每个物品要么装要么不装，且只有一个2.多背包问题，m个背包，背包j装入的最大重量为Bj在满足所有背包的约束条件下使得物品价值最大3.二维背包问题，多个约束条件，不仅仅有重量还有体积约束 例子：最长公共子序列问题：给定两个序列，求xy的最长公共子序列，要求字母出现的顺序一样的算法：1.蛮力算法：x的长度m，y的长度n。依次检查x的每个子序列在y中是否出现。时间复杂度分析：每个子序列O(n)时间，X有2^m个子序列，最坏情况的时间复杂度为O(n2^m)2.动态规划：子问题的界定与子问题的依赖关系满足优化原则以及子问题的重叠性递推方程标记函数通过标记函数遇到左上则输出该数，然后向左上方移动，遇到向上或者向左移动则移动即可时间与空间复杂度分析：标记函数迭代次数为O(mn)次，都是O(mn) 例子：黑白图像存储问题：每个像素的灰度值都不一样，但是都是0到255的范围，如果每个像素点都按照8为存储的话总的设计空间为8n思想：图像变位压缩将像素点进行分类，每一类的像素点个数以及占位多少不同，所以多了一个段头11位1对于方法1，一共分成三段，所以有11*3，第一段的最大15用4位存储即可，第二段最大255，用8位存储，第三段最大2，用两位存储 子问题的界定与计算顺序：前边界为1，后边界为i，优化函数s[i]存储最优分段存储位数算法设计：递推方程时间复杂度分析：从后向前追踪第j段的长度所以只要O(n) 例子：最大子段和问题：给定n个数（可以有负数）的序列，求最大的前子段和算法：1.蛮力算法：对所有的（i，j）顺序求和然后比较求出最大的和O(n^3)2.分治算法：将数组分成左右两半，分别计算左边的最大和，右边的最大和，跨边界的最大和，然后比较其中最大值O(nlogn)3.动态规划子问题界定：前边界为1，后边界i，c[i]为A[1···i]必须包含A[i]的向前连续延申的最大子段和递推方程 12参与比较的数为每i个数的最大值，要么是用前i-1的数c[i-1]加上A[i]或者直接是A[i]这里在c代码实现的过程中表示为前几项求和，如果求到求和小于0，则重新求和，每一轮比较一次最大值 最优二叉检索树问题：集合S为排序的n个元素，将这些元素存储在一颗二叉树的结点上，查找x是否在这些数当中，如果不在确定在哪个间隙检索数据的平均时间平均比较次数的计算问题：给定数据集，以及每个节点或者间隙的存取概论，求一颗最优的二叉检索树子问题划分以及规约子问题的概率求和优化函数的递推方程1之所以要加上w[i···j]，是因为向上延申的过程中，高度增加了1 递推方程：m[ij]=min{m[i,j]k | i&lt;=k&lt;=j}时间复杂度：ij的所有组合有平方个，每种最不同的k进行运算所以O(n^3)，空间复杂度为O(n^2) 序列比对问题：给定两个序列s1,s2，通过一定的字符编辑将s1转变成s2，完成这种编辑的最少操作的个数为编辑距离子问题的界定与规约优化函数的递推方程时间复杂度分析：因为子问题由ij界定有O(mn)个子问题，每个子问题的计算为常数，所以为O(mn)12345678动态规划的设计要点1.引入参数界定子问题的边界，注意子问题的重叠程度2.给出带边界参数的优化函数定义以及递推关系，找到递推关系的初值3.判断问题是否满足优化原则4.考虑是否使用标记函数5.自底向上从最小的子问题开始迭代计算，计算备忘录中优化函数和标记函数的值6.时间复杂度只要对所有的子问题（备忘录）工作量求和7.一般使用了较多的存储空间**瓶颈**","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/tags/算法设计与分析/"}]},{"title":"逻辑推理题","slug":"逻辑推理题","date":"2020-03-06T11:23:36.000Z","updated":"2021-03-13T01:55:16.683Z","comments":true,"path":"2020/03/06/逻辑推理题/","link":"","permalink":"http://yoursite.com/2020/03/06/逻辑推理题/","excerpt":"往年试题1分红推出不融资，融资推出不分红。所以分红与融资是相互排斥的，选项A的不融资其实就是分红，不分红其实就是融资，概括了所有，选项B的两句话是一句话","text":"往年试题1分红推出不融资，融资推出不分红。所以分红与融资是相互排斥的，选项A的不融资其实就是分红，不分红其实就是融资，概括了所有，选项B的两句话是一句话 12选项D的可能不能作为正确答案这题用了逆否命题 1这一题不要被绕进去了，静心分析","categories":[{"name":"复试","slug":"复试","permalink":"http://yoursite.com/categories/复试/"}],"tags":[{"name":"逻辑推理","slug":"逻辑推理","permalink":"http://yoursite.com/tags/逻辑推理/"}]},{"title":"C语言mooc试题","slug":"C语言","date":"2020-03-06T11:22:57.000Z","updated":"2021-03-13T01:56:09.189Z","comments":true,"path":"2020/03/06/C语言/","link":"","permalink":"http://yoursite.com/2020/03/06/C语言/","excerpt":"慕课试题分析回文数或者字符模块思想：回文数的判定为重新计算这个数，回文字符的判断只需一个循环判断每个字符是否相等就可以了","text":"慕课试题分析回文数或者字符模块思想：回文数的判定为重新计算这个数，回文字符的判断只需一个循环判断每个字符是否相等就可以了 程序改错12345常见类型：1.没有初始化为02.字符串链接最后一个字符要赋值为'\\0'3.二维数组的变换行i要乘的数是创建二维数组的列或者行的长度4.内存没有分配 一些例题例题：求正负余数思想：负余数加上除数然后再求余得到正余数 例题：计算时间差思想：采用结构体的形式，若第一个小时小于第二个则交换然后再做差值计算，分钟不够记得向小时借位，或者全部转换成分钟进行相减，然后取绝对值，最后再化成小时分钟形式1格式显示问题，在%-09d 的意思是左对齐然后不够的数补零（一般带左对齐不用补零），同理可知右对齐 例题：出租车计价思想：停车时间需要判断是否可以被5除，如果可以则不用再除以5之后加一，路程要进行判断不满一公里向前进位，所以要加一 例题：猜年龄问题：年龄的立方是个四位数而四次方是一个六位数，且每一个位都不一样思想：存储数组判断十个数都不相同，也就相当于每一位都不等于0，设置find变量进行判断 例题：计算心跳数问题：从出生到现在的总共的心跳数思想：sum+=(count-1+365(year-birth))246075;关键：在于得到的count为闰年数，如果今年也是闰年的话则需要减去1否则不用 程序改错1关键：容易陷入到只是判断scanf的正确对入的个数的问题，因为字符在c中被当作ASCII计算，所以应该设置多判断形式。1234567891011121314151617181920212223res =scanf(\"%d,%d\", &amp;x1, &amp;x2); switch(res) &#123; case 0: while(getchar()!='\\n');//读取缓冲区的所有内容，防止下次循环的错误输入 flag =1; break; case 1: while(getchar()!='\\n'); flag =1; break; case 2: if(x1*x2&gt;=0) &#123; flag=1; break; &#125; else &#123; flag =0; break; &#125; &#125; 程序改错2123456789char *pStr[M];printf(\"How many countries?\\n\");scanf(\"%d\",&amp;n);getchar(); /* 读走输入缓冲区中的回车符 */for(i=0; i&lt;n; i++)&#123; pStr[i] = (char *) malloc(sizeof(char)*N);//动态分配内存&#125;//直接初始化char* month[13] =&#123;\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"&#125;;//这里的初始化是对指针的地址初始化 例题：金字塔图案打印思想：关键设置两个变量，一个是res表示的与字符A之间的距离，表示空格打印个数以及总打印行数，然后是设置基础字符A循环打印1234567891011121314151617181920int res= a-'A'+1;char jishu;jishu = 'A';while(i&lt;res)&#123; for(j=i; j&lt;res; j++) &#123; printf(\" \"); &#125; for(k=0; k&lt;=i; k++) &#123; printf(\"%c\",jishu+k); &#125; for(k=i-1;k&gt;=0;k--) &#123; printf(\"%c\",jishu+k); &#125; printf(\"\\n\"); i++;&#125; 相似例题：打印减序的类似金字塔123456789do&#123; for(j=res;j&gt;=res-i;j--) &#123; printf(\"%c\" ,jichu+j-1); &#125; i++; printf(\"\\n\");&#125;while(i&lt;res); 例题：计算sinx思想：通过前一项计算后一项，关键点在一定要使用double类型的变量计算阶乘123456789do&#123; sigh = -sigh; res =ss*sigh/Fact(2*i-1); sum+=res; ss=ss*x*x; i++; count++;&#125; while(fabs(res)&gt;=1e-5); 例题：水手分椰子思想：最后留下一个所以最后一次分的时候一定是modn为1的，判定能否整除的方式有两种，一个是强制类型转换为int判断，或者直接设置成判断能整除才可以整除1234567891011do&#123; res=res*(n)/(n-1)+1; i++; if(res!=(int)res) &#123; i=1; x++; res=n*x+1; &#125;&#125;while(i&lt;n); 例题：好数对问题：一个集合当中的数任意两个不同的数相加的和也在集合当思想：三层循环 例题：计算工作还是休息思想：计算总的日子，然后对5取模 例题：统计用户输入思想：不一定非要用字符串来统计用户的输入的字符，可以直接一个循环单个字符读入判断1234567891011121314do &#123; ch =getchar() ; if(ch==' ') &#123; space++; &#125;else if(ch =='\\n') &#123; newline ++; &#125;else if(ch!='#') &#123; others++; &#125; &#125;while(ch!='#'); 例题：幻方矩阵**问题：每一行每一列对角线的和都是相同的12345678910111213141516for(i=0;i&lt;5;i++) &#123; for(j=0;j&lt;5;j++) &#123; sum[5+j]+=a[i][j];//记录每一列 sum[i] +=a[i][j];//记录每一行 if(i==j) &#123; dui1+=a[i][j]; &#125; if(i+j==4) &#123; dui2+=a[i][j]; &#125; &#125; &#125; 例题：寻找鞍点问题：矩阵中莫一行的最大值以及莫一列的最小值思想：保存每一行每一列的最大值最小值，然后在比较是否有相同的数有则输出即可 例题：蛇形矩阵思想：分成两段来打印，一段打印左上角包括对角线，一段打印右下角1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253while(i&lt;n &amp;&amp;j&lt;n)//最终这个循环会把左上角打印，结束的时候ij都为是n &#123; if(i==0) &#123; j++;//向右平移一个单位打印 a[i][j]=++count; while(j&gt;0)//结束的条件j会等于0 &#123; j--; i++;//向左下方移动 a[i][j]=++count; &#125; &#125; if(j==0) &#123; i++;//向下平移一个单位打印 a[i][j]=++count; while(i&gt;0)//结束的时候i会等于0 &#123; i--;//向右上方平移 j++; a[i][j]=++count; &#125; &#125; &#125; i=n-1; j=n-1; a[i][j]=s; while(i&gt;1 &amp;&amp;j&gt;1)//这里不是大于0而是大于1是因为不用重复打印对角线 &#123; if(i==n-1) &#123; j--;//在最后一行向左边移动 a[i][j]=--s; while(j&lt;n-1)//结束的时候j移动到最后一列 &#123; j++;//向右上方移动 i--; a[i][j]=--s; &#125; &#125; if(j==n-1) &#123; i--;//在最后一列向上移动 a[i][j]=--s; while(i&lt;n-1)//结束的时候i移动到最后一行 &#123; i++;//向左下方移动 j--; a[i][j]=--s; &#125; &#125; &#125; 例题：亲密数思想：计算一个范围内的亲密数的多少，可以用两次函数亲密数的亲密数还是自己来判断123456789for(i=1;i&lt;n;i++) &#123; int res=Judge(i); int res2= Judge(res); if(i==res2 &amp;&amp;res2&lt;res) &#123; printf( \"(%d,%d)\\n\",i,res); &#125; &#125; 例题：梅森尼数问题：形如2^i-1的素数思想：数据过大，应该用double类型存储并且判断方式发生改变1234567for(i=2;i&lt;=sqrt(n);i++) &#123; if(n/i == (int)(n/i)) &#123; return 0; &#125; &#125; 例题：查找子串经典思想：先判断找到第一个字符，然后一次循环找到后面的所有的字符一旦有一个不满则find置为0123456789101112131415161718for(i=0;i&lt;len1;i++) &#123; if(s[i] ==d[0]) &#123; find=1; for(j=1;j&lt;len2;j++) &#123; if(s[i+j] !=d[j]) &#123; find=0; &#125; &#125; if(find) &#123; return i+1; &#125; &#125; &#125; 例题：统计重复字符串思想：在一个函数中需要改变两个变量，不妨设置参数为指针类型12345678910111213141516for(i=0;i&lt;len1-1;i++) &#123; if(str[i]==str[i+1]) &#123; count++; if(max&lt;count) &#123; max = count; *tag =i; &#125; &#125; else &#123; count=1; &#125; &#125; 例题：出售金鱼思想：上题的找到第一个符合的设置find变量方法1234567891011121314151617181920212223do &#123; sum++; i=1; reminder=sum; if((i*reminder-1)%(i+1)==0) &#123; find=1; reminder = (i*reminder-1)/(i+1); for(j=2;j&lt;=4;j++) &#123; if ( (j*reminder-1)%(j+1)!=0) &#123; find=0; break; &#125;else &#123; reminder=(j*reminder-1)/(j+1); &#125; &#125; &#125; &#125; while(find==0 || reminder!=11 );//这里的判定条件是或者关系 例题：颠倒句子中的单词顺序思想:把最后一个的标点符号存储起来，然后将一个字符数组按照空格转换到二维数组当中1234567891011121314151617char ch = str1[len-1]; str1[len-1]='\\0'; int j=0,k=0,i=0; for(i=0; str1[i]!='\\0'; i++) &#123; if(str1[i]!=' ') &#123; str2[j][k]=str1[i]; k++; &#125; else &#123; str2[j][k] = '\\0'; j++; k=0; &#125; &#125; 例题：奇偶数分离思想：关键是打印的时候逗号的处理，首先用函数将奇数放在偶数后面然后打印或者直接两边遍历打印，第一次打印奇数第二遍打印偶数123456789101112131415161718192021222324for(i = 0; i &lt; n; i++) &#123; if(a[i]%2 == 1) &#123; if(count == 0) printf(\"%d\",a[i]); else printf(\",%d\",a[i]); count++; &#125; &#125; count = 0; printf(\"\\n\"); for(i = 0; i &lt; n; i++) &#123; if(a[i]%2 == 0) &#123; if(count == 0) printf(\"%d\",a[i]); else printf(\",%d\",a[i]); count++; &#125; &#125; 例题：字符串链接12345678910int i = 0,j=0; while (*(dest+i)!='\\0') i++;//先用一个循环把i放置到第一个字符的最后一个位置 for (; *(source+j)!='\\0'; j++) &#123; *(dest+i) = *(source+j); i++; &#125; *(dest+i) = '\\0';//关键要给最后一个赋值结束符 return dest; 例题：删除字符串中相同的字符12345678910111213do&#123; if(a[i] ==ch) &#123; for(j=i;j&lt;len-count;j++) &#123; a[j] =a[j+1]; &#125; a[j-1] ='\\0'; count++; i=-1; &#125; i++; &#125;while(a[i]!='\\0'); 例题：最大公约数问题：从大到小一次返回公约数12345678910111213141516171819int jishu=1;//通过设置全局变量来统计总共多少次，这是这一题的关键所在int CommonFactors(int a, int b)&#123; int i; int count=0; for(i=a; i&gt;=1; i--) &#123; if(a%i==0&amp;&amp;b%i==0) &#123; count++; &#125; if(jishu ==count) &#123; return i ; &#125; &#125; return -1;&#125; 例题：求解不等式123456789do&#123; res=0; for(i=0; i&lt;=m; i++) &#123; res=res +sqrt(m+i); &#125; m++;&#125;while(res&lt;=n);//记得打印m-1","categories":[{"name":"复试","slug":"复试","permalink":"http://yoursite.com/categories/复试/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"算法设计与分析之分治算法","slug":"算法设计与分析","date":"2020-03-06T11:21:49.000Z","updated":"2021-03-13T01:55:11.818Z","comments":true,"path":"2020/03/06/算法设计与分析/","link":"","permalink":"http://yoursite.com/2020/03/06/算法设计与分析/","excerpt":"分治算法分治策略的基本思想1原始问题划分为规模小的子问题 2递归或者迭代的求解每个子问题 3将子问题综合得到原问题的解注意子问题和原始问题的性质完全一样子问题之间彼此独立的求解递归停止时子问题可以直接求解","text":"分治算法分治策略的基本思想1原始问题划分为规模小的子问题 2递归或者迭代的求解每个子问题 3将子问题综合得到原问题的解注意子问题和原始问题的性质完全一样子问题之间彼此独立的求解递归停止时子问题可以直接求解 例子：二分检索思想：通过不断和中位数进行比较将问题的规模减半w(n) = w(n/2) +1w(n) =logn例子：二分归并排序思想：将原问题划分为规模为n/2的子问题无限划分直到只有一个数w(n) = 2w(n/2)+n-1w(1)=0 推出w(n) = nlogn -n+1例子：Hanoi塔递归的算法T(n) = 2T(n-1) +1T(1) = 1T(n) = 2^n-1例子：芯片测试输入：n个芯片，好芯片比坏芯片多一片 问题：设计一种测试方法从n个芯片中挑出一个好的芯片 要求：使用最少的测试次数分治算法的设计思想：假设n为偶数，两两一组进行测试淘汰，好好的任留一片，其他情况都抛弃。 递归截至条件为n&lt;=3一次测试可以得到好芯片。n为奇数的特殊处理：当n为奇数的时候，增加一轮对它的单独测试，如果是好的算法结束，否则淘汰它W(n) = w(n/2)+O(n)w(3)=1 W(2)=w(1)=0推出w(n)=O(n) 例子：快速排序最坏情况达到O(n^2) 最好的情况达到O(nlogn)例子：幂乘算法以及应用分治算法划分 改进分治算法的策略减少子问题的数量增加预处理例子：平面点对问题输入：平面点集p中有n个点，n&gt;1蛮力算法：C(n,2) 计算最小距离 O(n*2)分治策略：p划为大小相等的两个平面，在每一边找距离最小的，然后找跨边界的两个点的最小距离，找这些中的最小距离，其中跨边界找点的范围要在边界向外延申的距离&amp;为最小的左右两边的点的距离增加预处理原算法：在每次划分的时候对数组重新排序改进：1.在递归前对x,y排序，作为预处理2.在划分时候对数组x,y进行拆分时间为O(n) 选择最大和最小的问题蛮力算法：2*n-3的比较次数锦标赛算法：分组进行比较，利用空间换时间时间复杂度的分析：W(n) = n + [logn] -2; 选择第k小的数字简单算法：调用k次选择最小的算法,时间复杂度为O(kn)或者先排序后输出第k小的算法,时间复杂度为O(nlogn)分治算法：选择一个标准数将s划分为s1与s2，s1都比m小，s2都比m大时间复杂度分析：w(n) = w(n/5)+w(7n/10)+cn算出来的结果是w(n) =O(nlogn) 卷积及其应用卷积的应用为信号平滑处理，卷积与多项式乘法的系数也相关卷积计算：蛮力算法，相当于多项式乘法，时间复杂度为O(n^3)&emsp;快速傅里叶变换 平面集的凸包问题：给定大量离散点的集合，求一个最小的凸多边形，使得所有点都在里面或者边上分治算法：1.链接最大纵坐标和最小的纵坐标点的线段划分左点集与右点集 &emsp;2.确定距离线段d最远的点p在三角形内部的点都删除，在三角形外的构成子问题时间复杂度分析：w(n) =w(n-1)+O(n)w(3)=O(1)（最坏情况为O(n^2)）凸包算法：O(nlogn)","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/tags/算法设计与分析/"}]},{"title":"数据库之mooc刷题","slug":"数据库之mooc刷题","date":"2020-03-06T11:20:14.000Z","updated":"2021-03-13T01:55:17.727Z","comments":true,"path":"2020/03/06/数据库之mooc刷题/","link":"","permalink":"http://yoursite.com/2020/03/06/数据库之mooc刷题/","excerpt":"第十四讲1解析：传递律成立，但是传递函数依赖更加严格 1解析：前两个组合起来可以有12推出35，然后35推出6","text":"第十四讲1解析：传递律成立，但是传递函数依赖更加严格 1解析：前两个组合起来可以有12推出35，然后35推出6 第十五讲1解析：商品和商店可以推出商品部，商店和商品部可以推出商品部经理，候选键为商店和商品，不存在部分函数依赖，但是有传递依赖，所以满足第二范式但是不满足第三范式 1解析：候选键为AB，对于候选键也没有传递依赖，所以是满足boyee-codd范式的 第十六讲1解析：不一定可以保证函数依赖关系，d是对的 12解析：判断无损链接：求两个的交集，然后如果交集可以推出其中任意一个分解，则是无损的。函数依赖判断：所有的依赖集合中的项都在分解中表示出来了的话，就表示保持了函数依赖 第十七讲1234数据库重组是对数据表的物理存储进行调整dbms可以将若干个表存储在一个文件中，也可以将一个表的数据存储在多个文件上create table有三个方面的功能：定义关系模式，定义完整性约束，定义物理存储结构堆文件的组织结构中，记录是以输入顺序存储的 第十八将1234567一个主文件可以建立多个索引，更新时索引全部更新，但是只有一个可决定物理存储的索引主索引：对每一个存储块都有一个索引项，通常是稀疏索引，建立在主码的排序字段上，按索引字段值排序的一个有序文件稠密索引：按照字段值进行排序的一个有序文件，对每一个不同的值有一个项DBMS不一定会总是在索引中先查找，而是根据检索条件判断是否使用索引只有主索引是DBMS自动建立和维护的，其他的索引都要DBA建立，但是所有的索引都是DBMS自动维护的聚簇索引：邻近的记录在主文件中一定是邻近存储的，可能存在重复键值的索引项一个主文件只可以有一个聚簇索引文件，可以有多个非聚簇索引文件 b+树：叶结点索引项x的左侧指针，指向=x的主文件存储块。非叶节点索引项x的左侧指针，指向&lt;x的索引文件存储块b+树可以建立候选键的稀疏索引，主文件必须按照该属性排序存储，建立候选键的稠密索引，则可按可不按，建立非候选键的稠密索引，也是可按可不按。所以只要是稠密索引，都是可按可不按 第十九讲1选择操作和包上的并操作，在任何时候都可以用一趟算法实现，而集合上的并操作不一定用一趟算法实现 1解析：聚簇存储不使用索引为磁盘块数，使用的话用元组数除以磁盘块数。非聚簇存储的话，代价是元组数 1解析：这题是选择错误的，有些是要建立起完整的数据结构才可以进行分组的聚集运算 第二十讲12 第二十一讲12连接运算的代价估计为1/max（v,r）*元组数目两个的与运算的估计为两个相乘，或运算的估计为1-（1-y）（1-x）然后都要乘以 第二十二讲1读事务之前要加锁，在两个都锁住之前不能有一个解锁 第二十三讲12undo是从尾部开始，直到遇到第一个检查点为止redo是按照日志记录的正序处理，由前向后处理，然后自该检查点开始恢复，直到尾部结束","categories":[{"name":"复试","slug":"复试","permalink":"http://yoursite.com/categories/复试/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据库","slug":"数据库","date":"2020-03-06T11:20:14.000Z","updated":"2021-03-13T01:55:17.256Z","comments":true,"path":"2020/03/06/数据库/","link":"","permalink":"http://yoursite.com/2020/03/06/数据库/","excerpt":"mooc刷题第四讲1解析：交不是基本运算 1解析：做θ链接时不需要将公共属性合并，而自然链接需要，所以是大于，等值链接是θ链接的特例 1解析：注意看清楚，不是做的链接操作而是笛卡尔乘积","text":"mooc刷题第四讲1解析：交不是基本运算 1解析：做θ链接时不需要将公共属性合并，而自然链接需要，所以是大于，等值链接是θ链接的特例 1解析：注意看清楚，不是做的链接操作而是笛卡尔乘积 第五讲1解析：score这个变量是在sc关系中，所以是u[score] 123解析：三种运算都是非过程性的，相比下，域演算&gt;元组演算&gt;关系代数关系代数与安全的元组与域演算是等价的优先级的比较，非&gt;与&gt;或 123解析：关系演算不一定是安全的，但是关系代数是一种集合运算，是安全的安全的元组和域演算可以等价交换关系演算以元组或者域变量作为基本处理单位 第六讲1解析：数据定义语言：create，alter，drop数据控制语言：grant，revoke数据操作语言：select，update，delete，insert 1解析：必修没有加引号 第七讲1解析：union必须是对应的列以同一顺序出现，group by和having是可以在子查询中出现的 1解析：注意这里的分组的方式是按照课程号分类的，所以表示的该课程有两人以上不及格，选出学号 第八讲1解析：是安全性约束 1解析：外键是定义的表约束 第九讲1解析：多个事务之间可能相互影响，但是DBMS会解决 1解析：where current of 是更新或者删除当前游标记录 1解析：for update 表示既可以跟新也可以删除表数据 第十讲1解析：数据字典是有DBA创建与维护的，并且可以用sql语言查询，它由表和视图构成 1解析：statement是对特定的数据库执行sql语句，perparedstatement是用于执行预编译的sql语句，callablestatement是用于执行数据库内嵌过程的调用，result从当前执行的sql语句中返回结果 123解析：嵌入式sql语言的思维模式是与游标相关，建立变量是fetch时绑定odbc的思维模式是与句柄相关，开始之前就用专门的语句绑定jdbc的思维模式是与对象相关，和嵌入式sql一样，边绑定，边读取 第十一讲12解析：er模型是概念模型，而层次网状模型是数据模型概念模型是对信息世界的抽象，数据模型是对计算机世界的抽象 1解析：本意是学生选择课程，一个课程可以对应多个班级，所以不应该在课程中 1解析：元模型抽象的层次更加高，模型是在元模型下面的 第十二讲12解析：非标定联系，基数可以为空值也就是0到多IDEF1X中没有类实体到对象实体 1解析：不可以以空值出现，则应该是标定联系，而出现多次则应该在标定联系中再加上一个新字段 第十三讲12解析：概念数据库阶段是与er图相关，逻辑数据库设计阶段与关系模式相关，物理数据库设计阶段依赖与具体的dbms，逻辑数据库设计：关系模式设计与规范化处理 12解析：d明显说反了，应该是单方的关键字放在多方的属性中不完全分类的泛化实体不可以丢掉","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"离散数学","slug":"离散数学","date":"2020-03-06T11:14:10.000Z","updated":"2021-03-13T01:55:16.084Z","comments":true,"path":"2020/03/06/离散数学/","link":"","permalink":"http://yoursite.com/2020/03/06/离散数学/","excerpt":"图论12345678910导出子图：首先S是V的子集，然后所有在V的边E如果在S中有，都必须要有生成子图：所有的顶点都在，边随便选通道：顶点和边的交错序列迹：通道上的边互不相同路：各顶点互不相同奇数度的结点的个数为偶数欧拉闭迹：包含所有顶点和所有边欧拉图：等价于连通且每个顶点度都是偶数哈密顿路：包含所有顶点的路哈密顿图：有哈密顿圈","text":"图论12345678910导出子图：首先S是V的子集，然后所有在V的边E如果在S中有，都必须要有生成子图：所有的顶点都在，边随便选通道：顶点和边的交错序列迹：通道上的边互不相同路：各顶点互不相同奇数度的结点的个数为偶数欧拉闭迹：包含所有顶点和所有边欧拉图：等价于连通且每个顶点度都是偶数哈密顿路：包含所有顶点的路哈密顿图：有哈密顿圈 不存在自补图的顶点个数为6，7存在正五边形的五个顶点和五条边构成的图为自补图","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://yoursite.com/tags/离散数学/"}]},{"title":"项目管理","slug":"项目管理","date":"2019-01-03T02:11:35.000Z","updated":"2021-03-13T01:53:06.006Z","comments":true,"path":"2019/01/03/项目管理/","link":"","permalink":"http://yoursite.com/2019/01/03/项目管理/","excerpt":"软件软件定义20世纪五十年代：软件=程序面向过程的程序=算法+数据结构20世纪六十年代：软件=程序+文档20世纪七十年代：软件=程序+文档+数据","text":"软件软件定义20世纪五十年代：软件=程序面向过程的程序=算法+数据结构20世纪六十年代：软件=程序+文档20世纪七十年代：软件=程序+文档+数据 面向对象的程序=对象+消息面向构件的程序=构件+构架 软件的特点软件是一种逻辑实体开发过程中没有明显的制造过程软件是知识和智慧型产品软件不会磨损 软件开发过程软件产品开发需求分析根据客户的要求，掌握客户需求中的产品功能，特性，性能，界面和具体规格等，然后进行分析业务需求：组织或者客户的总体要求，重点在于为什么要开发这个系统，要达到什么样的目标用户需求：具体用户的要求，用户要求系统能完成的任务，即用户能使用这个系统做什么（对应功能）功能需求：规定系统要实现的功能，用户利用这些功能完成工作，满足业务需求，描述开发人员要实现什么非功能需求：主要指系统需求，包括系统应达到的性能，可靠性，安全性，易用性，侧重于系的质量属性 软件产品开发设计考虑如何实现所定义的产品功能，特性等，一般分为概要设计和详细设计，也可以分为数据结构设计，软件体系结构设计，应用接口设计，模块设计，界面设计等 软件开发过程典型模型瀑布模型：文档驱动，开发阶段有顺序性和依赖性，适用于需求明确小规模软件开发快速原型模型：根据初步需求快速建立模型，逐步修改，完善，适用于用户需求不明确的小规模软件开发增量模型：需要开放式体系结构，初期构件是基础，适用于软件开发周期较长可持续合作的软件螺旋模型：融合了瀑布于原型法的特点，适合企业内部大规模软件开发喷泉模型：面向对象的软件开发，可以提高软件开发效率，节省开发时间，项目管理有难度 软件开发过程管理从大量的实践中归纳总结出的行之有效的过程为最佳实践软件过程管理就是在软件开发过程中，对最佳实践进行有效的积累形成可重复的软件过程，使得最佳实践在组织范围内共享软件过程管理可以将个人能力转变为企业的能力 主要内容过程定义：对最佳实践进行总结，形成一套稳定的可重复的软件过程过程改进：发现问题，不断优化，提高软件过程能力软件质量是软件产品满足使用要求的程度，正常的运行意味着软件必须尽可能没有bug 软件能力成熟度CMM初始级，可重复级，定义级，管理级，优化级KPA包含五个公共特性：实施保证，实施能力，执行活动，度量分析，实施验证可重复级包括：需求管理，项目管理：计划过程和跟踪与监控过程，质量管理，配置管理和子合同管理 能力成熟度集成CMMISE-CMM：系统工程CMM，应用于系统工程管理SA-CMM：软件采购CMM，应用于软件获取（采购）方的能力成熟度模型IPD-CMM：集成系统产品开发CMM，应用于集成系统产品的开发管理P-CMM：人力资源能力成熟度模型，应用于人力资源管理CMMI模型包括“阶段式成熟度能力”和“持续式过程能力”两种实施方法。PSP/TSP：个人软件过程和团队软件过程PSP：是一种可用于控制，管理和改进软件工程师个人工作方式的自我改善过程，是一个包括软件开发表格，指南和规程的结构化框架 项目管理基本概念项目：为了实现一个独特的目的而进行的临时性任务，是一种被承办的旨在创造某种独特产品活服务的一次性努力 项目 日常活动 一次性 重复进行 目标为导向 通过效率和有效性体现 项目经理及其团队工作完成 职能式的管理 存在变更管理 持续性的 项目管理：在项目活动中运用专门的知识，技能，工具和技术，使项目能够实现或超过项目利益相关者的需要和期望项目干系人：积极参与项目或其利益在项目执行中或成功后收到积极或消极影响的组织和个人项目管理的关键要素：需求和目标是项目实施的基本要求，资源是项目实施的根本保证，项目组织是项目实施运作的核心实体，环境是项目成功的可靠基础 现代项目管理三大特点：由阶段性管理转化为全过程管理，由经验管理转化为科学管理，由微观管理发展为宏观管理发展趋势：全球化，多元化，专业化项目管理组织结构的三种类型：职能型，项目型，矩阵型 项目范围管理项目范围的含义：包括项目的最终产品或者服务，以及实现所需要完成的全部工作产品范围：产品或者服务所包含的特征或者功能工作范围：为交付具有规定特征和功能的产品或服务所必须要完成的工作项目范围管理的主要过程：项目启动，范围计划，范围界定，范围核实，范围变更控制项目范围界定：逐级分解项目任务，使其变成更小，更易管理的单元工作分解结构WBS：是一种以结果为导向的分析方法，用于分析项目所涉及的工作，所有这些分解的工作构成项目的整体范围WBS分解方式：按结构分解，按功能分解，按过程分解，按目标分解项目范围核实：项目生命周期的各阶段结束时发生，是项目收尾的一部分，关注于工作结果的正确性项目范围控制：管理范围的变更，目的是确保项目的变化可及时响应，处理，包括及时的跟踪和有效的控制 项目时间管理项目进度计划是项目最基本的控制工具时间是最主要的成本依据PMBOK项目时间管理：活动定义，活动排序，活动历时估计，制定进度计划，进度计划控制活动定义：也是范围管理的范畴活动排序和工期估算：编制工期计划的基石制定进度计划：计算整个工期长度，确定起始以及结束时间，设置阶段性里程碑进度控制：把进度计划与实施进程的偏差尽量控制在允许的范围内项目工作活动的相互关系：结束到开始的关系最为常用，典型的逻辑关系，开始到结束关系极少使用确定工作时间的主要方法：专家判断和类比估计 项目成本管理 完成软件项目相应符出的代价 待开发的软件项目需要的资金 人的劳动的消耗所需要的代价是软件产品的主要成本 开发成本是以一次性开发过程所花费的代价计算的项目需求不确定，采用的技术先进有风险，个人行为，独特性，缺少历史资料借鉴，受企业发展影响软件质量管理质量：反映实体满足主体明确和隐含需求的能力的特征总和质量应该包括准确性，稳定性，可靠性，安全性，适用性，可拓展性实体：可单独描述和研究的事物，质量工作的对象，如活动，过程，产品或者组织等明确需求：相关文档中已经做出规定的需要隐含需求：用户和社会对实体的期望以及公认的不必明确的需求软件质量是软件产品满足使用要求的程度项目质量：项目作为一项最终产品来看，项目质量体现在性能和使用价值上，即项目的产品质量工作质量是产品质量的保证主要环节：质量保证，质量控制，质量工程的实践影响质量的因素：人，机，料，法（Method），环（Environment）质量成本：保证和提高产品质量，满足用户需要而支出的费用，以及因未达到质量标准而产生的一切损失费用的总和，传统的质量成本包括预防成本，鉴定成本，内部损失成本，外部损失成本质量管理：在质量方面的指挥和控制组织的活动项目质量管理：组织为使产品质量满足不断更新的质量要求、达到顾客满意而开展的策划、组织、实施、控制、保证、检查、审核和改进等所有相关管理活动的总和项目人力资源管理有效发挥每个参与项目人员的作用的过程，管理的对象是所有的利益相关者项目沟通管理沟通的含义：为了设定的目标，把信息，思想和感情在个人或者群体间传递并达成共同协议的过程保证项目信息能够被及时、正确地产生、收集、发布、存储以及最终进行信息处理过程。参与项目的每一个人都必须使用项目“语言”传达和接收信息，理解他们以个人身份涉及的信息将如何影响整个项目重要性决策与计划的基础组织和控制管理过程的依据和手段建立和改善人际关系必不可少的条件成功领导的重要手段沟通的障碍组织障碍：制度或者职能约束：官僚主义 部门间协作：利益影响个人障碍：知识经验水平的差距，对信息的态度不同，相互不信任，畏惧感及个人心理品质沟通的方法正式，非正式，上行，下行，平行，单向，双向，书面，口头非语言沟通的方式：手势，眼神，表情，姿态，音调项目风险管理风险风险是指损失或损害的可能性由于项目所处的环境和条件的不确定性等因素，项目最终结果与项目利益相关者的期望产生背离，并给利益相关者带来损失的可能性从狭义上理解即可能发生的危险从广义上理解即不确定性的存在项目风险管理通过风险识别、风险评估去认识项目的风险，并以此为基础合理的使用各种管理办法、技术和手段对项目风险实行有效的控制，妥善处理风险事件所造成的不利后果，以最少的成本保证项目总体目标实现的过程项目风险管理过程风险识别，风险评估，风险应对，风险控制项目采购管理项目采购是指从项目系统外部获得项目所需产品或者服务的完整采办过程分类：按采购对象：货物（设备和工具）和咨询服务按采购方式：招标和非招标在整个项目实施过程中，项目组织对从外部寻求和采购各种项目所需资源（商品和劳务）的管理过程","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://yoursite.com/tags/项目管理/"}]},{"title":"React","slug":"React","date":"2018-12-27T02:57:11.000Z","updated":"2021-03-13T01:55:42.760Z","comments":true,"path":"2018/12/27/React/","link":"","permalink":"http://yoursite.com/2018/12/27/React/","excerpt":"React简介JSXJSX语法中，可以使用自己创建的组件，一般大写字母开头","text":"React简介JSXJSX语法中，可以使用自己创建的组件，一般大写字母开头 生命周期函数某一个时刻组件会自动调用执行的函数例如：render()：props或者state发生改变的时候自动调用constructor()componentWillMount()：组件即将被挂载到页面的时刻执行componentDidMount()：组件挂载完之后执行shouldComponentUpdate()：组件被更新之前会执行componentWillUpdate()：shouldComponentUpdate函数之后render之前执行componentDidUpdate()：组件更新完成之后执行componentWillReceiveProps()：从父组件接收了参数，只要父组件的render函数重新被执行了，子组件的生命周期函数就会被执行，如果这个组件第一次存在于父组件之中，不会执行，这个组件已经存在于父组件中，才会执行componentWillUnmount()：当这个组件即将被从页面移除的时候执行 Updation用store import {connect} from ‘react-redux’; export default connect()(Topic);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2018-12-19T07:14:03.000Z","updated":"2021-03-13T01:55:47.172Z","comments":true,"path":"2018/12/19/JavaScript/","link":"","permalink":"http://yoursite.com/2018/12/19/JavaScript/","excerpt":"写一点自己的理解吧点击函数的写法点击函数经常使用，最简单的就是var bianliang =document.getElementById(“id”);bianliang.onclick=function(){}或者bianliang.on(“click”,funciton()){}或者在前端界面的id处写一个onclick=”test()”，然后在JS中写function test()","text":"写一点自己的理解吧点击函数的写法点击函数经常使用，最简单的就是var bianliang =document.getElementById(“id”);bianliang.onclick=function(){}或者bianliang.on(“click”,funciton()){}或者在前端界面的id处写一个onclick=”test()”，然后在JS中写function test() ajax和getJSON $.getJSON( url, //请求URL [data], //传参，可选参数 [callback] //回调函数，可选参数 );ajax异步传递数据，用的真的很频繁$.ajax({ type: “post/get”, url: “”, data: JSON.stringify({“key”: value}), dataType: “json”, contentType: “application/json;charset=UTF-8”, success: [callback]{ }, }) documentdocument.querySelector(“#id”)：读取某个id里面的元素document.getElementById(“id”) canvascanvas对象表示一个html画布var canvas1 = document.getElementById(‘canvas1’);var context1 = canvas1.getContext(‘2d’);context1.drawImage(video,0, 0, 300, 300);//前两个确定左上角开始画的坐标，后两个确定宽和高 浏览器对象navigator获取用户浏览器摄像头navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"代码优化","slug":"代码优化","date":"2018-12-12T11:35:19.000Z","updated":"2021-03-13T02:07:25.444Z","comments":true,"path":"2018/12/12/代码优化/","link":"","permalink":"http://yoursite.com/2018/12/12/代码优化/","excerpt":"优化的种类机器相关性：寄存器，多处理器，特殊指令优化，无用指令消除优化范围：局部优化：单个剧本快范围内的优化，常量合并优化，公共子表达式删除。计算强度消弱和无用代码删除。全局优化：基于循环的优化：循环不变优化，归纳变量删除，计算强度消弱优化语言级：针对中间代码，针对机器语言","text":"优化的种类机器相关性：寄存器，多处理器，特殊指令优化，无用指令消除优化范围：局部优化：单个剧本快范围内的优化，常量合并优化，公共子表达式删除。计算强度消弱和无用代码删除。全局优化：基于循环的优化：循环不变优化，归纳变量删除，计算强度消弱优化语言级：针对中间代码，针对机器语言 公共子表达式消除复制传播复制传播变换的思想是在复制语句f := g之后尽可能用g代替f，复制传播变换本身并不是优化，但它给其它优化带来机会 无用代码删除无用代码是指的是计算结果以后不被引用的语句 代码外提将循环不变计算从循环中移除到循环的前面 强度消弱实现同样的运算可以有多种方式，用计算较快的运算代替慢的 控制流分析对循环优化-&gt;分析控制流程。首先要将程序划分为基本块集合并转换成流图，然后从流图中找出循环 基本块基本块(basic block)是一个连续的语句序列，控制流从它的开始进入，并从它的末尾离开，中间不存在中断或分支(末尾除外) 流图程序的控制流信息可以用流图表示，节点为基本块的有向图。以程序的第一个语句作为入口语句的节点称为初始节点如果在某个执行序列中B2跟随在Bl之后，则从Bl到B2有一条有向边。如果从Bl的最后一条语句有条件或无条件转移到B2的第一个语句；或者按程序正文的次序B2紧跟在Bl之后，并且Bl不是结束于无条件转移，则称B1是B2的前驱，而B2是Bl的后继 局部优化基本块的功能实际上就是计算一组表达式，，这些表达式是在基本块出口活跃的变量的值。如果两个基本块计算一组同样的表达式，则称它们是等价的。 可以对基本块应用很多变换而不改变它所计算的表达式集合，许多这样的变换对改进最终由某基本块生成的代码的质量很有用。利用基本块的dag表示可以实现一些常用的对基本块的变换⑴ 局部公共子表达式删除。⑵ 无用代码删除。⑶ 交换两个独立的相邻语句的次序，以便减少某个临时值需要保存在寄存器中的时间。⑷ 使用代数规则重新排列三地址码的运算对象的顺序，以便简化计算过程。 循环优化循环不变计算的检测代码外提归纳变量删除和强度削弱 全局优化全局公共子表达式的删除复制传播","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2018-12-06T08:18:27.000Z","updated":"2021-03-13T01:55:39.072Z","comments":true,"path":"2018/12/06/SpringBoot/","link":"","permalink":"http://yoursite.com/2018/12/06/SpringBoot/","excerpt":"说明云计算大作业目的是学习调用华为云的API，然后前后端的框架选择了SpringBoot Spring的简史第一阶段：Spring 1.x时代，随着项目的扩大，xml配置文件放到不同的配置文件第二阶段：注解配置，Spring提供声明Bean的注解，大大减少了配置量。应用的基本配置用xml，业务配置用注解第三阶段：Java配置，Spring提供了Java配置，使用Java配置可以让你更理解你所配置的Bean。SpringBoot：使用Spring Boot很容易创建一个独立运行、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置","text":"说明云计算大作业目的是学习调用华为云的API，然后前后端的框架选择了SpringBoot Spring的简史第一阶段：Spring 1.x时代，随着项目的扩大，xml配置文件放到不同的配置文件第二阶段：注解配置，Spring提供声明Bean的注解，大大减少了配置量。应用的基本配置用xml，业务配置用注解第三阶段：Java配置，Spring提供了Java配置，使用Java配置可以让你更理解你所配置的Bean。SpringBoot：使用Spring Boot很容易创建一个独立运行、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置 Controller@RestController：注解相当于@ResponseBody ＋ @Controller。使用@Controller 注解，在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页。若返回json等内容到页面，则需要加@ResponseBody注解，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面@RequestMapping：配置web请求的映射@PostMapping：@RequestMapping(method = RequestMethod.POST)的缩写@GetMapping：@RequestMapping(method = RequestMethod.GET)的缩写GET和POST最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数@RequestParam：GET和POST中请求传的参数会自动赋值到其注解的变量上@RequestBody：用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容，一般是来处理application/json类型。假如我有一个User类，拥有如下字段：String userName;String pwd;那么上述参数可以改为以下形式：@RequestBody User user 这种形式会将JSON字符串中的值赋予user中对应的属性上。需要注意的是，JSON字符串中的key必须对应user中的属性名，否则是请求不过去的。HttpServletRequest：代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息 Session简单介绍在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务 Session和Cookie的主要区别Cookie是把用户的数据写给用户的浏览器Session技术是把用户的数据写到独占的Session中Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象 Session实现原理服务器创建sesssion出来后，会把session的id号，以cookie的形式回写给客户机，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务 mapper为一个接口，它的方法实现与数据库相关在mapper映射文件.xml文件中的头写入表示调用的相关mapper为UserMapper。id为映射的方法，parameterType为输入参数。resultType为返回参数 service包含一个接口类和接口实现类implimpl类中包含注解@service和@Autowired的mapper接口对象，用该接口对象调用对数据库操作的方法，在controller中有@Autowired的service接口对象 model实体类 application.properties配置数据库：spring.datasource.username=root spring.datasource.password=xxxspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC&amp;allowMultiQueries=true配置thymeleaf：spring.thymeleaf.cache=truespring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8配置mybatis：","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Git","slug":"Git","date":"2018-12-05T09:32:36.000Z","updated":"2021-03-13T01:55:59.709Z","comments":true,"path":"2018/12/05/Git/","link":"","permalink":"http://yoursite.com/2018/12/05/Git/","excerpt":"什么是Git目前世界上最先进的分布式版本控制系统 创建版本库版本库就是一个仓库，里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪将当前目录变为仓库：git init将文件添加到暂存区：git add 文件名 [可选：另一个文件名]将暂存区提交到仓库：git commit –m “描述”","text":"什么是Git目前世界上最先进的分布式版本控制系统 创建版本库版本库就是一个仓库，里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪将当前目录变为仓库：git init将文件添加到暂存区：git add 文件名 [可选：另一个文件名]将暂存区提交到仓库：git commit –m “描述” 时光机穿梭掌握仓库当前的状态：git status 查看某个具体文件的改变：git diff wenjian.txt 版本回退git log:显示最近到最远的提交日志(回到过去)git中HEAD表示当前版本，上一个版本是HEAD^git reset –hard HEAD^：回退到上一个版本git reset –hard 1094a^：回到某一个版本git reflog：记录每一次的命令(回到未来) 工作区和暂存区工作区就是你在电脑里能看到的目录.git文件不是工作区是一个Git的版本库，版本库中存了很多东西，最重要的是stage或者index的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的指针HEAD 撤销修改git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：&emsp;&emsp;一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。 删除文件git rm：用于删除一个文件(暂存区) 远程仓库ssh-keygen -t rsa -C “1084930331@qq.com“：申请密钥 添加远程库git remote add origin git@github.com:michaelliao/learngit.git添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令之后就用git push origin master推送最新的修改一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 从远程库克隆git clone git@github.com:michaelliao/gitskills.git 分支管理创建和合并分支git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch dev git checkout devgit branch命令查看当前分支，一般回到master分支上然后进行merge合并git merge命令用于合并指定分支到当前分支。git branch -d dev：删除分支 解决冲突解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log –graph命令可以看到分支合并图。 分支管理策略在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了： Feature分支开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origingit remote：查看远程库的信息加上-v显示更详细的信息git push origin master：把master推送给远程库origingit pull把最新的提交从origin/dev抓下来 标签管理创建标签先切换到要打标签的分支上，然后git tag 就可以了，默认打在最新提交的commit上git tag f52c633：对具体的id打标签git tag：查看标签git show &lt;tag_name&gt;：显示标签信息 操作标签删除标签：git tag -d 删除远程标签：git push origin :refs/tags/推送某个标签到远程：git push origin","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"运行时的存储组织","slug":"运行时的存储组织","date":"2018-12-03T13:10:56.000Z","updated":"2021-03-13T01:55:05.499Z","comments":true,"path":"2018/12/03/运行时的存储组织/","link":"","permalink":"http://yoursite.com/2018/12/03/运行时的存储组织/","excerpt":"与存储组织相关的源语言概念与特征给定一个源程序，编译程序必须根据源语言的特征为源程序中的许多问题做出决策，包括何时、怎样为名字分配内存地址。静态策略：在编译时即可做出决定的策略动态策略：直到程序执行时才能做出决定的策略","text":"与存储组织相关的源语言概念与特征给定一个源程序，编译程序必须根据源语言的特征为源程序中的许多问题做出决策，包括何时、怎样为名字分配内存地址。静态策略：在编译时即可做出决定的策略动态策略：直到程序执行时才能做出决定的策略 名字及其绑定“名字”、“变量”和“标识符” 的区别与联系名字和变量分别表示编译时的名字和运行时该名字所代表的内存位置。标识符则是一个字符串，用于指示数据对象、过程、类或对象的入口。所有标识符都是名字，但并不是所有的名字都是标识符，名字还可以是表达式。例如，名字x.y可能表示x所代表结构的域y。同一标识符可以被声明多次，但每个声明都引入一个新的变量。即使每个标识符只被声明一次，局部于某个递归过程的标识符在不同的运行时刻也将指向不同的内存位置。环境：是一个从名字到内存位置的映射状态：是一个从内存位置到它所保存的值的映射 声明的作用域x的声明的作用域是程序中的这样一段区域，在该区域中，x的引用均指向x的这一声明。对于某种程序设计语言，如果只通过考察其程序就可以确定某个声明的作用域，则称该语言使用静态作用域；否则称该语言使用动态作用域静态作用域规则：如果名字x的声明D属于程序块B，则D的作用域是B的所有语句，只有满足如下条件的程序块B’除外：B’嵌套在B中(可以是任意的嵌套深度)，且B’中具有同一名字x的一个新的声明。显式访问控制：类和结构为其成员引入了一种新的作用域如果p是某个带有域(成员)x的类的对象，则p.x中x的引用将指向该类定义中的域x动态作用域相对于时间 过程及其活动把一个标识符和一组语句联系起来的，该标识符是过程名，这组语句是过程体。过程体的每次执行叫做该过程的一个活动 参数传递方式1.传值：被调用过程为每个形参开辟一个称为形式单元的存储单元，用于存放相应实参的值，调用过程计算实参，并把右值放在相应的形式单元中2.传地址：把实参的地址传递给被调用过程3.传值结果：将传值和传地址两种方式结合起来4.传名：用实参表达式对形参进行文字替换，类似于宏替换 存储组织运行时内存的划分为运行目标程序，编译器需要先获得一块存储区，并划分成块 活动记录过程的每个活动所需要的信息用一块连续的存储区来管理，这块存储区叫做活动记录。采用栈式存储分配机制连接数据：返回地址，动态链，只指向调用者的活动记录。静态链，访问存放在其他活动记录中的非局部数据形式单元：存放相应的实在参数的地址或值。局部数据区：局部变量、内情向量、临时工作单元(如存放对表达式求值的结果)。 局部数据的组织局部数据域在编译过程中处理声明语句时进行分配变量所需的存储空间可以根据其类型而静态确定。一个过程所声明的局部变量，按这些变量声明时出现的次序，在局部数据域中依次分配空间。局部数据的地址可以用相对于某个位置的地址来表示。数据对象的存储安排还有对齐的问题，整数必须放在内存中特定的位置 全局存储分配策略静态存储分配策略：如果在编译时能确定数据空间的大小，则可采用静态分配方法：在编译时刻为每个数据项目确定出在运行时刻的存储空间中的位置动态存储分配策略：如果在编译时不能确定运行时数据空间的大小，则必须采用动态分配方法。允许递归过程及动态申请、释放内存。 静态存储分配策略如果在编译时就能确定一个程序在运行时所需要的存储空间的大小，在编译时就能安排好目标程序运行时的全部数据空间，确定每个数据项的地址 栈式存储分配策略过程的每次调用都将触发一个活动，过程的每个活动所需要的数据被组织成活动记录，必须保存每个活动相应的数据区内容，引入一个运行栈，让过程的每次执行和过程的活动记录相对应。每调用一次过程，就把该过程的活动记录压入栈中，返回时弹出。 调用序列和返回序列过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态等 运行时的存储分配策略分为静态和动态分配，动态又分为栈式和堆式，C语言的静态变量采用静态分配，而自动类变量采用栈式分配，使用malloc申请的内存单元为动态分配","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"符号表管理","slug":"符号表管理","date":"2018-12-03T12:17:33.000Z","updated":"2021-03-13T02:06:32.319Z","comments":true,"path":"2018/12/03/符号表管理/","link":"","permalink":"http://yoursite.com/2018/12/03/符号表管理/","excerpt":"符号表的作用协助进行语义检查(如检查一个名字的引用和之前的声明是否相符)和中间代码生成在目标代码生成阶段，当需要为名字分配地址时，符号表中的信息将是地址分配的主要依据编译器用符号表来记录、收集和查找出现在源程序中的各种名字及其语义信息。符号表是以名字为关键字来记录其信息的数据结构，其上支持的两个最基本操作应该是添加表项和查找表项，这两个操作必须是高效的","text":"符号表的作用协助进行语义检查(如检查一个名字的引用和之前的声明是否相符)和中间代码生成在目标代码生成阶段，当需要为名字分配地址时，符号表中的信息将是地址分配的主要依据编译器用符号表来记录、收集和查找出现在源程序中的各种名字及其语义信息。符号表是以名字为关键字来记录其信息的数据结构，其上支持的两个最基本操作应该是添加表项和查找表项，这两个操作必须是高效的 符号表中存放的信息记录源程序中出现的各种名字及其属性信息是符号表的首要任务。显然同一个名字在一段程序中应该表示同一个对象，即同一个符号表中不能出现相同的名字，因此名字可以作为符号表的关键字。 符号表中的名字名字字段长度固定：名字项的长度大小取决于标识符允许的最大长度，不适于标识符长度变化范围较大的语言，空间浪费名字字段长度可变：标识符的长度没有限制，符号表上的操作复杂而低效 符号表中的属性符号所表达的含义不同，符号表中需要存放的属性也就不同方法1：建立多个符号表来管理源程序中出现的各种符号，如常数表、变量表、函数表、数组表等问题：可能出现不同种类符号重名的问题方法2：建立一张共用的大表来管理各种符号，需要在符号表增设一个标志来表明符号的种属问题：不同种类符号所需存放属性信息在数量上的差异将会造成符号表的空间浪费 符号的地址属性如果采用静态存储分配策略，则符号x绑定的地址等于静态分配的基址base加上符号x的偏移量offset如果采用的是栈式存储分配或堆式存储分配等动态分配策略，则符号是在程序执行过程中和地址动态绑定的。如栈式存储分配时，i的地址是以栈指针sp为基址加上i相对于活动记录起始地址的偏移量offset i符号表中各符号的地址属性就是该符号相对于第一个符号的偏移地址 符号表的组织结构符号表的线性表实现数组实现：插入n个符号、执行e次查找操作的时间复杂度为T(n, e) = O(n(n+e))有序数组实现：插入n个符号、执行e次查找操作的时间复杂度为T(n, e)≤ O(n+e)log n+O(n2)有序符号表结构只有在下面的情况下才能取得较好效果：和插入操作次数相比，符号表表项上的查找操作次数占绝对多数，即e&gt;&gt;n。 符号表的散列表实现引入散列表不仅可以提高lookup操作的效率，同时也可以提高insert操作的效率，所以在许多实际编译器的符号表实现中均采用了散列技术 符号表与作用域程序块结构的符号表每个程序块建立一个符号表，程序块内的符号记录在该程序块所对应的符号表中,还要建立起这些符号表之间的联系,以刻画出符号的嵌套作用域。实现的问题：有时需要维护的符号表数量太大 程序块结构符号表的其他实现将所有块的符号表放在一个大数组中，然后再引入一个程序块表来描述各程序块的符号表在大数组中的位置及其相互关系将符号所属程序块编号放在符号表表项中。查找某个符号的名字name时，只有当name和符号表中的名字字符串完全匹配，且符号表表项中的块编号和当前处理的块编号完全相同时才算查找成功。程序块编号可以通过在语法制导定义中的块开始处和块结束处添加适当的语义规则计算得出。程序块满足最近嵌套原则 C语言的符号表一个完整的C程序由一个或多个相对独立的函数组成，函数之间的通信依靠参数传递和全局变量全局变量和函数名的作用域是整个程序，而其余变量的作用域则是定义它们的函数如果采取将每个函数分别编译成目标代码然后连接装配成一个可执行程序的处理方式，则每个函数中的符号经一遍处理即可，而且源程序中的多个函数是一个接一个处理的，不会出现交叉 小结符号表用来存放编译器各阶段收集来的各种名字的类型和特征等有关信息，并供编译程序用于语法检查、语义检查、生成中间代码及生成目标代码等；源程序中会出现各种各样的名字，如函数名、函数参数名、函数中的局部变量名、全局变量名、数组名、结构名、文件名等，相应的属性可以是种属、类型、地址等。根据符号所需的属性个数和类型的不同，可以组成不同的符号表，也可以组成统一的符号表，在组成统一符号表时，需要采用恰当的组织结构，以便可以对其进行高效处理。随着程序规模的扩大，符号名的数量会很大，因而必须关注符号表的组织和高效管理。无序线性符号表、有序线性符号表、散列表示符号表具有不同性能的组织形式。符号表管理中必须关注到语言所规定的符号的作用域，特别是在嵌套结构的程序中，符号的作用域是分层的。C语言符号表的管理","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"SSM(Spring+SpringMVC+MyBatis)","slug":"Javaee的一点点知识","date":"2018-12-02T08:45:19.000Z","updated":"2021-03-13T01:55:52.527Z","comments":true,"path":"2018/12/02/Javaee的一点点知识/","link":"","permalink":"http://yoursite.com/2018/12/02/Javaee的一点点知识/","excerpt":"SSMSpring和bean&lt;beans…/&gt;元素是Spring配置文件的根元素，&lt;beans…/&gt;元素可以包含多个&lt;bean…/&gt;子元素，每个&lt;bean…/&gt;元素可以定义一个Bean实例，每一个Bean对应Spring容器里的一个Java实例定义Bean时通常需要指定两个属性。Id：确定该Bean的唯一标识符，容器对Bean管理、访问、以及该Bean的依赖关系，都通过该属性完成。Bean的id属性在Spring容器中是唯一的。","text":"SSMSpring和bean&lt;beans…/&gt;元素是Spring配置文件的根元素，&lt;beans…/&gt;元素可以包含多个&lt;bean…/&gt;子元素，每个&lt;bean…/&gt;元素可以定义一个Bean实例，每一个Bean对应Spring容器里的一个Java实例定义Bean时通常需要指定两个属性。Id：确定该Bean的唯一标识符，容器对Bean管理、访问、以及该Bean的依赖关系，都通过该属性完成。Bean的id属性在Spring容器中是唯一的。 Class：指定该Bean的具体实现类。注意这里不能使接口。通常情况下，Spring会直接使用new关键字创建该Bean的实例，因此，这里必须提供Bean实现类的类名。Spring容器集中管理Bean的实例化，Bean实例可以通过BeanFactory的getBean(String beanid)方法得到。BeanFactory是一个工厂，程序只需要获取BeanFactory引用，即可获得Spring容器管理全部实例的引用。程序不需要与具体实例的实现过程耦合。大部分Java EE应用里，应用在启动时，会自动创建Spring容器，组件之间直接以依赖注入的方式耦合，甚至无须主动访问Spring容器本身。当我们在配置文件中通过方法配置一个Bean时，这样就需要该Bean实现类中必须有一个无参构造器 SpringMvcSpring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 MyBatisMyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 Src里面有五个主要的包，action，mapper,model,service,service.impl action包其实就是servlet，servlet就是小服务程序或服务连接器，交互式地浏览和修改数据，生成动态web。前端点击后通过href连接传入到这个包中的文件里面有很多个注解：1.@Controller：注明这个类为控制器2.@RequestMapping：有很多属性，value：String[]类型，将URL映射到方法上或者类上。method：用来支出该方法只处理哪些类的请求。method=RequestMethod.POST，仅仅处理post请求。consumes：指定处理请求的提交类型（Content-Type），String[]类型。produces：指定返回的内容类型，返回的内容类型必须是request请求头（Accept）中所包含的类型。String[] 类型。params：指明了request请求中包含了某些参数值时，才让该方法处理。String[] 类型。headers：指明了request请求中包含了某些指定的header值，才让该方法处理。String[] 类型。3.@RequestParam：用于将request请求参数中的值，赋给方法中的形参。以下是属性说明value：请求参数的名称。是默认属性，当注解只有一个属性时，可以省略。String类型。required：参数是否必须。boolean类型。defaultValue：如果没有传参而使用的默认值。String类型。4.@Autowired：自动装配，Spring会自动将我们标记为@Autowired的元素装配好，注入Bean的方法。HttpServletRequest：当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。HttpSession：一个session就是一系列某用户和服务器间的通讯。服务器有能力分辨出不同的用户。一个session的建立是从一个用户向服务器发第一个请求开始，而以用户显式结束或session超时为结束。void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性，例如：session.setAttribute(“xxx”, “XXX”)，在session中保存了一个域属性，域属性名称为xxx，域属性的值为XXX mapper包包含接口类和对应的接口类方法的数据库实现操作(xml) model包实体类的定义在这 service包接口类 service.impl包实现service包中的接口类，具体的方法还是调用Mapper类中的对数据库中数据进行操作 config包里卖包含三个文件：spring-mvc.xml,mabatis-config.xml,spring.common.xmlspring.common.xml：主要是封装类和默认对象的属性，1.有数据源的配置，即连接数据库。2.mybatis的SqlSession的工(value=”classpath:config/mybatis-config.xml”)。3. mybatis自动扫描加载Sql映射文件/接口 : MapperScannerConfigurer sqlSessionFactory basePackage:指定sql映射文件/接口所在的包（自动扫描）(value=”com.dhee.mapper”)。4.事务管理。5.使用声明式事务spring-mvc.xml：1.springMVC扫描的带有@Controller包不能被spring监听器所扫描到，否则会将springMVC中的请求路径给过滤掉，所以(context:component-scan base-package=”com.dhee.action”)。2.视图解析器。3.防止处理静态请求mabatis-config.xml：与Spring相关的配置不在这个文件中，它里面包含1.为实体类设置别名。2.实体接口映射资源，映射到具体的xml文件进行数据库的操作web.xml（不在包中但是配置文件）：1.spring的监视器ContextLoaderListener2.springMVC的分发器DispatcherServlet，注意需要写入spring-mvc.xml配置文件所在路径和控制分发的请求路径3.其他配置，配置字符编码等","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Javaee","slug":"Javaee","permalink":"http://yoursite.com/tags/Javaee/"}]},{"title":"语义分析与中间代码生成","slug":"语义分析与中间代码生成","date":"2018-11-29T07:17:55.000Z","updated":"2021-03-13T01:55:05.938Z","comments":true,"path":"2018/11/29/语义分析与中间代码生成/","link":"","permalink":"http://yoursite.com/2018/11/29/语义分析与中间代码生成/","excerpt":"中间代码的形式抽象语法树，逆波兰表示，三地址码，DAG图 逆波兰表示后缀表示法：运算顺序就是运算符出现的顺序。中缀表达式a:=ab+cd，前缀表达式：:=a+abcd，后缀表达式：abcbd+:=","text":"中间代码的形式抽象语法树，逆波兰表示，三地址码，DAG图 逆波兰表示后缀表示法：运算顺序就是运算符出现的顺序。中缀表达式a:=ab+cd，前缀表达式：:=a+abcd，后缀表达式：abcbd+:= 三地址码代码的每条指令最多只能包含三个地址，即两个操作地址和一个结果地址。三地址码中地址的形式：名字、常量、编译器生成的临时变量。常用的实现方式有三元式和四元式 图表示无回路有向图(DAG)可以消除公共子表达式在DAG中代表公共子表达式的节点具有多个父节点 声明语句的翻译声明语句的作用是为程序中用到的变量或常量名指定类型，而类型的作用主要体现在1.类型检查：是否符合规则2.辅助翻译：确定存储空间 类型表达式1．基本类型是类型表达式。Boolean、char、integer、real、void2．类型名是类型表达式3．将类型构造符array应用于数字和类型表达式所形成的表达式是类型表达式4．如果T1和T2是类型表达式，则其笛卡尔乘积T1×T2也是类型表达式。5．类型构造符record作用于由域名和域类型所形成的表达式也是类型表达式。6．如果T是类型表达式，那么pointer(T)也是类型表达式，表示“指向类型为T的对象的指针” 类型等价结构等价：下面的条件之一成立：1.T1和T2是相同的基本类型；2.T1和T2是将同一类型构造符应用于结构等价的类型上形成的；3.T1是表示T2的类型名。如果将类型名看作只代表他们自己的话，前两个条件将导致类型表达式的名字等价两个类型表达式名字等价当且仅当他们完全相同 声明语句的文法 过程内声明语句的翻译声明语句的翻译就是在符号表中为每个局部名字创建一个表项，同时维护该名字的类型及相对地址等信息 赋值语句的翻译辅助子程序：gencode(code) ：产生一条中间代码 newtemp：产生新的临时变量 lookup：检查符号表中是否出现某名字，如果有，则返回指向该表项的指针语义属性设置：中间代码序列：code 地址：addr 下一条四元式序号：nextquad 简单赋值语句的翻译主要任务：生成对表达式求值的三地址码 数组元素的寻址Elist.array，用来记录指向符号表中相应数组名字表项的指针。Elist.ndim，用来记录Elist中下标表达式的个数，即Elist的维数。Elist.addr，用来临时存放Elist的下标表达式计算出来的值。limit(array, j)，返回nj，即由array指示的数组的第j维的维长 带有数组引用的赋值语句的翻译 类型检查发现程序错误的能力，确定这些类型表达式是否符合一定的规则，这些规则的集合通常称为源程序的类型系统 类型检查的规则类型综合：从子表达式的类型确定表达式的类型，要求名字在引用之前必须先进行声明，典型的逻辑规则：if f的类型为s→t and x的类型为s then 表达式f(x)的类型为t类型推断：根据语言的使用方式来确定其类型，通常用于从函数体推断函数类型，逻辑规则：if f(x)是一个表达式，对于其赋值情况和参数计算方式，then f具有类型α→β (两个类型变量α和β) and x具有类型α 类型转换 控制结构的翻译控制语句的翻译与布尔表达式的翻译有关，布尔表达式的两个作用：计算逻辑值和改变控制流程 布尔表达式的翻译not&gt;and&gt;or 常见控制结构的翻译 布尔表达式的控制流翻译 混合模式的布尔表达式翻译引入语义属性：E.type: arith 或者bool E.true, E.false：E为布尔表达式 E.addr：E为算术表达式 回填在生成跳转语句时可能不知道控制要转向的指令的标号，一种解决方法是先生成暂时没有指定目标标号的一系列跳转指令，每个这样的指令都将放在一个跳转指令链表中，指令标号要等到目标标号确认下来才能填入翻译模式用到如下三个函数：1．makelist(i)：创建一个只包含i的新表，i是四元式数组的一个索引(下标)，或者说i是四元式代码序列的一个标号。2．merge(p1, p2)：合并由指针p1和p2指向的两个表并且返回一个指向合并后的表的指针。3．backpatch(p，i)：把i作为目标标号回填到p所指向的表中的每一个转移指令中去。此处的“表”都是为“回填”所准备的链表 布尔表达式的回填式翻译 常见控制结构的回填式翻译 switch语句的翻译过程调用和返回语句的翻译输入输出语句的翻译","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"语法指导翻译与属性文法","slug":"语法指导翻译与属性文法","date":"2018-11-28T03:29:32.000Z","updated":"2021-03-13T01:55:06.550Z","comments":true,"path":"2018/11/28/语法指导翻译与属性文法/","link":"","permalink":"http://yoursite.com/2018/11/28/语法指导翻译与属性文法/","excerpt":"语法指导翻译概述编译程序划分成前端和后端，前端包括词法分析，语法分析，语义分析，中间代码生成，符号表的建立，以及和机器无关的中间代码优化。后端通常包括和机器相关的代码优化，目标代码生成，相关的错误处理以及符号表的访问语义分析器的主要任务是检查各个语法结构的静态语义，即验证语法正确的程序结构是否真正有意义，也称为静态语义分析或静态检查","text":"语法指导翻译概述编译程序划分成前端和后端，前端包括词法分析，语法分析，语义分析，中间代码生成，符号表的建立，以及和机器无关的中间代码优化。后端通常包括和机器相关的代码优化，目标代码生成，相关的错误处理以及符号表的访问语义分析器的主要任务是检查各个语法结构的静态语义，即验证语法正确的程序结构是否真正有意义，也称为静态语义分析或静态检查 类型检查：操作数和操作符的类型是否相容；控制流检查：控制流转向目标地址是否合法；惟一性检查：对象是否被重复定义；关联名检查：同一名字多次特定出现是否一致将静态检查和中间代码生成结合到语法分析中进行的技术称为语法制导翻译在进行语法分析的同时，完成相应的语义处理如何根据被识别出来的语法结构进行语义处理？1.语法指导定义2.语法指导翻译模式 语法指导定义（SDD)综合属性：该节点或子节点属性值计算出来继承属性：该节点，该节点的兄弟节点或父节点的属性值计算出来固有属性：通过词法分析直接得到的属性，归类于综合属性(终结符只有综合属性，非终结符都可以有，文法的开始符号的继承属性要提前定义)副作用：打印某个值或者修改某个全局变量属性文法：没有副作用的SDD，语义规则单纯根据常数和其他属性的值来定义某个属性的值S-属性定义：只含综合属性，通常在自底向上的分析方法计算属性值出现在产生式左边的继承属性和出现在产生式右边的综合属性都不由所给的产生式的属性计算规则进行计算 属性计算依赖图依赖图其实就是一个有向图，用于描述分析树中节点的属性和属性间的相互依赖关系。每个属性对应依赖图中的一个节点，如果属性b依赖于属性c，则从属性c的节点有一条有向边指向属性b的节点。属性间的依赖关系是根据相应的语义规则确定的。如果依赖图中没有回路，则利用它可以很方便地求出属性的计算顺序。 属性的计算顺序拓扑顺序：若依赖图中有环，不存在拓扑顺序，属性的计算存在循环依赖关系，若无环，则存在一个拓扑顺序，就是属性值的计算顺序 S-属性定义只含综合属性的SDD称为S-属性定义，可以按照自下而上的顺序来计算分析树中节点的属性。一种简单的属性计算方法是对分析树进行后根遍历，在最后一次遍历节点N时计算与节点N相关联的属性 L-属性定义当且仅当它的每个属性或者是综合属性，或者是满足如下条件的继承属性：设有产生式A→X1X2…Xn，右部符号Xi (1≤i≤n)的继承属性只依赖于下列属性：⑴ A的继承属性；⑵ 产生式中Xi左边的符号X1、X2、…、Xi-1的综合属性或继承属性；⑶ Xi本身的综合属性或继承属性，但前提是Xi的属性不能在依赖图中形成回路。 属性计算示例抽象语法树是把分析树中对语义无关紧要的成分去掉，是分析树的抽象形式。构造表达式的抽象语法树使用的函数1.mknode(op, left, right) 建立一个标记为op的运算符结点，两个域left和right分别是指向左右运算对象的指针。2.mkleaf(id, entry) 建立一个标记为id的标识符结点，其域entry是指向该标识符在符号表中相应表项的指针。3.mkleaf(num, val) 建立一个标记为num的数结点，其域val用于保存该数的值。 翻译模式（SDT）翻译模式是语法制导定义的一种实现形式。其中属性与文法符号相关联，语义规则(也称为语义动作)用花括号｛ ｝括起来，可插入到产生式右部任何合适的位置。继承属性先计算出来，综合属性最后面计算如果综合属性和继承属性都有，在建立翻译模式的时候就必须保证：1.产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来2.一个动作不能引用这个动作右边的符号的综合属性3，产生式左边非终结符的综合属性只有在它所引用的属性都计算出来才能计算，通常在产生式右端的尾部 翻译模式有语义动作的执行时机翻译模式设计的前提：保证语义动作不会引用还没计算出来的属性值1.只有综合属性的情况：直接把赋值动作放在相应的产生式右部的末尾2.既有综合属性又有继承属性：产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来。一个动作不能引用这个动作右边符号的综合属性。产生式左边非终结符号的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右部的末尾。 S-属性定义的自底向上翻译后缀式语法指导翻译模式：将语义规则放在产生式末尾形成语法翻译。归约前调用相应的语义子程序，完成翻译的任务S属性文法的计算：在分析栈中使用一个附加的域存放综合属性值 L-属性定义的自顶向下翻译消除左递归：1.只有简单语义动作时的左递归消除，带着语义动作走2.S-属性定义的左递归消除。例如：A→A1Y｛A.a:=g(A1.a,Y.y)} A→X ｛A.a:=f(X.x)} 消除后： A→X｛R.i:=f(X.x} R｛A.a:=R.s} R→Y ｛R1.i:=g(R.i,Y.y)} R｛R.s:=R1.s} R→ε ｛R.s:=R.i}引入继承属性R.i来收集应用函数g的计算结果。其初始值为A.a:=f(X.x）引入综合属性R.s在R结束生成Y时复制R.i的值。 L-属性定义的自底向上翻译关键：如何自底向上地计算继承属性修改文法：1.计算继承属性的动作嵌入在非终结符的前面，而将计算综合属性的动作放在产生式的末尾2.在每个嵌入动作处引入一个标记性非终结符不同位置对应的标记不同形如M-&gt;ε的产生式3.如果标记性非终结符M取代了某个产生式A→α{a}β中的动作a，则为M设置继承属性来复制动作a所需要的A或α中符号的继承属性；以与动作a相同的方式计算属性，只不过要将这些属性置为M的综合属性。","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"自底向上的语法分析","slug":"自底向上的语法分析","date":"2018-11-26T09:52:00.000Z","updated":"2021-03-13T01:56:19.107Z","comments":true,"path":"2018/11/26/自底向上的语法分析/","link":"","permalink":"http://yoursite.com/2018/11/26/自底向上的语法分析/","excerpt":"自底向上的语法分析概述输入串出发反复归约，最后可以得到文法的开始符号，则输入串是相应文法的一个句子。在分析的过程中，寻找当前句型最左的和某个产生式的右部相匹配的子串","text":"自底向上的语法分析概述输入串出发反复归约，最后可以得到文法的开始符号，则输入串是相应文法的一个句子。在分析的过程中，寻找当前句型最左的和某个产生式的右部相匹配的子串 最右推导为规范推导 最左归约为规范归约 移进归约分析一张分析表，一个输入缓冲区，一个分析栈，一个输出缓冲区格局：栈+输入缓冲区剩余内容 优先法思想：根据归约的先后次序为句型中相邻的文法符号规定优先关系句柄内相邻符号同时归约，是同优先级的句柄两端符号的优先级要高于句柄外与之相邻的符号简单优先文法：如果各文法符号之间的优先关系互不冲突(至多存在一种优先关系)，则可识别任意句型的句柄算符优先文法：仅对文法中可能在句型中相邻的终结符定义优先关系，并且各终结符对之间的优先关系互不冲突。 状态法根据句柄的识别状态来识别句柄1.移进归约冲突2.归约归约冲突 算符优先分析法将句型中的终结符当作算符，然后定义算符之间的某种优先关系，利用优先关系来寻找句柄进行归约 算符优先文法表达式的运算次序和运算对象没有关系，而只和运算符的优先级有关系如果文法G中不存在具有相邻非终结符的产生式，则称为算符文法。在无ε产生式的算符文法Ｇ中，如果任意一对终结符之间至多有一种优先关系，则称为算符优先文法。 算符优先矩阵的构造FIRSTOP(A)={b|A+b…或者A+Bb…, b∈T, B ∈V} （最左终结符集合）LASTOP(A)={b|A+…b或者A+…bB, b∈T, B ∈V} （最右终结符集合）终结符的优先关系小于FIRSTOP大于LASTOP 算符优先分析算法素短语至少包含一个终结符，除自身以外不再包含其他含终结符的短语栈内优先级高则归约否则移进 优先函数分成栈内优先函数和栈外优先函数，可能不存在对应优先关系表的优先函数，若存在也不唯一。存在的话，可以通过三个步骤构造优先函数1.画图：a&gt;=b 从fa画一条弧线到gb，如果a&lt;=b，从gb画一条弧线到fa2.数数：从一个节点出发能到达的节点(沿着线随意走的经过点，包括它自己)3.检查：是否与原来的关系矛盾 算符优先分析的出错处理语法错误：1.栈顶的终结符号和当前输入符号之间不存在任何优先关系(修改栈，输入)2.发现被归约对象但不是任何产生式的右部(继续将这些符号出栈) LR分析法L:自左向右扫描输入符号R:构造最右推导的逆过程LR文法不是二义的，二义文法一定不是LR的 LR分析算法句柄：非形式的，句柄是和某个产生式右部匹配的字符串，把句柄归约成产生式左部的非终结符，可以得到最右推导的逆过程的一步举例：E-&gt;E+E|EE|-E|(E)|id，对于id+idid，其中一个最右推导为E-&gt;E+E-&gt;E+EE-&gt;E+Eid-&gt;E+idid-&gt;id+idid。在id+idid归约成E+idid的过程中，最左边的id是句柄。E+idid归约成E+Eid时，最左边的id是句柄，把E+Eid归约成E+EE时，id是句柄。把E+EE归约成E+E时EE是句柄。E+E归约成E时，E+E是句柄。前缀：如abc的前缀是a,ab,abc活前缀：举个例子，比如E+EE归约成E+E，句柄是EE，那么它的活前缀就是E、E+、E+E、E+E、E+EE。又比如id+idid归约成E+idid，句柄是最左边的id，那么它的活前缀是id，因为不能超过句柄 LR(0)分析表的构造项目集闭包：从一个项目出发e-可达的所有项目集合后继项目：识别一个非终结符后进入的项目闭包之间的转移：GO(I,X)=CLOSURE({A→αX.β| A→α.Xβ∈I}归约归约冲突 移进归约冲突 SLR(1)分析表的构造在FOLLOW集中才可以进行归约否则进行移入只能排除不合理归约但是不能找到正确的归约还是有移入归约冲突，归约归约冲突 LR(1)分析表的构造在特定位置，A的后继符集合是FOLLOW(A)的子集[A→α.β, a]的项为LR(1)项，a为一个终结符表示在当前状态下，A后面必须紧跟终结符，称为该项的展望符如何给给定的文法构造LR(1)自动机，同样的求闭包同时要把展望符也给求出来 LALR(1)分析表的构造合并同心项目集，会产生归约归约冲突，不会有移入归约冲突可能会推迟错误的发现形式上与LR(1)相同，大小上与LR(0)/SLR相同，分析能力介于SLR与LR(1)之间 二义性文法的应用任何一个二义性文法都不是LR的，某些二义性文法对语言的说明和实现非常有用，只要指明消除二义性的规则，还是少用 LR分析中的出错处理紧急方式的错误恢复：从栈顶开始退栈，直至发现在某个语法变量A上具有转移的状态S为止, A通常是主要程序结构的语法变量。丢弃零个或多个输入符号，直至找到符号a FOLLOW(A) 为止。分析器把状态goto[S，A]压进栈，并恢复正常分析 SLR(1)判断规则方法一：画出文法的LR(0)自动机，如果没有移进–规约冲突，即shift–reduce 冲突，则该文法是SLP(1)文法LR(1)&gt;LALR(1)&gt;SLR(1)&gt;LR(0)","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"自顶向下的语法分析","slug":"自顶向下的语法分析","date":"2018-11-25T06:10:07.000Z","updated":"2021-03-13T01:56:16.557Z","comments":true,"path":"2018/11/25/自顶向下的语法分析/","link":"","permalink":"http://yoursite.com/2018/11/25/自顶向下的语法分析/","excerpt":"语法分析概述语法分析是编译程序的核心部分，其任务是检查词法分析器输出的单词序列是否为源语言中的句子，也就是是否符合源语言的语法规则主要有两种方式1.产生句子的方式：从开始符号逐步推导出单词序列，自顶向下分析（递归子程序法，预测分析法LL(1)）2.识别句子的方式：逐步将构成程序的单词序列归约成文法的开始符号，自底向上分析（算符优先分析法，LR(0),SLR(1),LR(1),LALR(1)）","text":"语法分析概述语法分析是编译程序的核心部分，其任务是检查词法分析器输出的单词序列是否为源语言中的句子，也就是是否符合源语言的语法规则主要有两种方式1.产生句子的方式：从开始符号逐步推导出单词序列，自顶向下分析（递归子程序法，预测分析法LL(1)）2.识别句子的方式：逐步将构成程序的单词序列归约成文法的开始符号，自底向上分析（算符优先分析法，LR(0),SLR(1),LR(1),LALR(1)） 这两种方式都是自左向右地扫描输入单词序列，针对输入单词序列建立一颗语法分析树语法分析处理时的恢复策略：紧急方式恢复策略（丢弃直到发现同步记号：; end）短语级恢复策略（对剩余输入做局部纠正） 自顶向下的语法分析面临的问题与文法的改造面临的问题1.二义性问题解决方法：改造文法，引入新的文法变量或者根据优先级关系，保证高优先级运算符优先的原则2.回溯问题：多个候选式3.左递归引起的无穷推导问题 对上下文无关文法的改造1.消除二义性2.消除左递归：A→Aα|β替换为A→βA’ A’ →αA’ |ε 间接左递归只要采用代入法变为直接左递归就可以3.提取左因子：将公共前缀提取出来解决以上三个问题才能实现确定的自顶向下分析 LL(1)文法FIRST(X):可以从X推导出的所有串首终结符构成的的集合，如果可以推出空串FIRST(α)={a|α aβ，aT，β(V∪T)*}计算FIRST集：产生式右部的第一个是终结符，直接加，是非终结符，将该非终结符的FIRST集加入到产生式左部的FIRST集中。不断循环调用直到没有新的可以加入。FOLLOW(A):可能在某个句型中紧跟在A后边的终结符的集合，如果A是句型的最右符号，则将结束符#加入到FOLLOWa(A)中。计算FOLLOW(A)集合：首先将#放入FOLLOW(S)中，因为S是开始符号，#输入右端的结束标记。计算的符号的后面跟着终结符则直接加入，产生式左部的FOLLOW集合可以在产生式右部的最后一个非终结符的FOLLOW集，不断循环直到没有新的可以加入。SELECT(产生式)：若产生式右部不为空，则为产生式右部的第一个非终结符的FIRST集，或产生式右部的第一个终结符，若右部为空，则为产生式左部的FOLLOW集。相同产生式左部的SELECT集不相交则为LL(1)文法 预测分析法该方法是一种高效的自顶向下的分析方法。预测分析程序采用该方法实现语法分析，所以叫预测分析器，又可以在无附加条件时对LL(1)文法实现确定的自顶向下分析，有时也叫LL(1)分析器。 预测分析器的构成 预测分析表的构造分析栈中一开始存放栈底符号#和文法的开始符号，然后根据栈顶符号A和读入的符号查看分析表M决定执行相应的动作计算方法：计算FIRST和FOLLOW集合进行填表操作 预测分析中的错误处理错误有：栈顶终结符号和下一个输入符号不匹配，栈顶是语法变量A，a是下一个输入符号M[A,a]是空白表项 紧急方式错误恢复策略：发现错误时跳过一些输入符号，直到下一个语法成分包含的第一个符号为止（同步记号）使用方法：M[A,a]表项是synch，表明a属于follow(A)，弹出A，继续执行下面的分析1.如果表项M[A, a]为空，则跳过输入符号a；2.如果表项是synch，则弹出栈顶的语法变量并试图恢复分析；3.如果栈顶的记号与输入符号不匹配，则从栈顶弹出该记号 递归下降分析法基本思想为每个语法变量编写一个处理子程序，终结符直接匹配，非终结符就调用处理子程序 语法图和递归子程序法 语法图的化简与实现左右因子提取和消除尾递归","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"编译原理词法分析","slug":"编译原理词法分析","date":"2018-11-23T00:34:37.000Z","updated":"2021-03-13T01:55:20.313Z","comments":true,"path":"2018/11/23/编译原理词法分析/","link":"","permalink":"http://yoursite.com/2018/11/23/编译原理词法分析/","excerpt":"词法分析器的功能词法分析器读入表示源程序的字符流，按照程序功能等价的要求，将其转换成对应的单词序列，并剔除其中的空格、注解等不影响程序的字符","text":"词法分析器的功能词法分析器读入表示源程序的字符流，按照程序功能等价的要求，将其转换成对应的单词序列，并剔除其中的空格、注解等不影响程序的字符 单词的分类和表示单词是程序语言中具有独立意义的最小语法单位&emsp;&emsp;（1）关键字：也叫基本字，多用来作为语句的标识&emsp;&emsp;（2）标识符：用来表示各种名字，如变量名、过程名和数组名&emsp;&emsp;（3）常数：分为整常数、实常数和字符串常数&emsp;&emsp;（4）运算符：又可以分为算术运算符（+-=）；逻辑运算符（not or and）；以及关系运算符（&lt;&gt; &gt;= &lt;=）&emsp;&emsp;（5）分界符：又叫界限符（,;()）把单词表示成二元组：（种别，属性值） 源程序的输入缓冲和预处理1.超前搜索和回退&emsp;&emsp;例如对单词&lt;&gt;，&gt;=2.缓冲区&emsp;&emsp;1）双缓冲区&emsp;&emsp;开始指针：指向当前识别单词的第一个字符&emsp;&emsp;向前指针：指向当前读入的字符&emsp;&emsp;2）带标记的缓冲区&emsp;&emsp;在缓冲区两部分的结尾处各设置了一个“标志”，每次移动向前指针只要测试是否遇到了eof，如果是，则判断是否为缓冲区某半部分的末尾，不是则不进行进一步的测试3.空白字符的剔除&emsp;&emsp;放在输入串被放在缓冲区之前完成，进行适当的预处理 词法分析阶段的错误处理错误通常包括以下几种(1)非法字符：@(2)单词拼写错误：began(3)注解或字符常数不封闭：/*…(4)变量重复对错误的处理：1.检查2.错误恢复和续编译&emsp;最简单的错误恢复策略为紧急方式恢复 单词的描述正则文法正则文法描述的是T上的正则语言 正则表达式正则式，正规式正则表达式所表示的语言称为正则集 正则表达式与正则文法的等价性1.为正则文法的每个产生式构造一个正则表达式方程式方程式构造规则2.解联立方程组，求等价的正则表达式r代入消元规则正则定义式对于任意在字母表上的正则表达式r，形如A-&gt;r的式子 有穷状态自动机有穷状态控制器：从输入带上读入字符，每读一个字符，读头就指向下一个待读入的字符有穷状态自动机是一个五元组：状态的非空有穷集合；状态转移函数；开始状态；终止状态；接收状态 正则表达式转换成状态转换图 单词的识别如何利用有穷状态自动机来进行单词的识别 有穷状态自动机和单词识别的关系一个字符一个字符的逐步识别，看成有限个状态的变换 单词识别的状态转换图表示 几种典型的单词识别问题主要是超前搜索和回退。回退一般用栈来实现 状态转换图的实现单词的识别规则库实现方式访问速度快但是浪费空间多访问速度慢但是节省空间","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"编译原理第二章","slug":"编译原理第二章","date":"2018-11-22T12:45:51.000Z","updated":"2021-03-13T01:55:21.289Z","comments":true,"path":"2018/11/22/编译原理第二章/","link":"","permalink":"http://yoursite.com/2018/11/22/编译原理第二章/","excerpt":"语言概述语言是一定的群里进行信息交流的一种工具单词是按照一定的规则由字符组成的串句子是按照一定的规则由单词组成的串程序是按照一定的规则由语句组成的串语言是语句的集合程序设计语言：组成程序的所有语句的集合程序：满足语法规则的语句序列语句：满足语法规则的单词序列单词：满足词法规则的字符串","text":"语言概述语言是一定的群里进行信息交流的一种工具单词是按照一定的规则由字符组成的串句子是按照一定的规则由单词组成的串程序是按照一定的规则由语句组成的串语言是语句的集合程序设计语言：组成程序的所有语句的集合程序：满足语法规则的语句序列语句：满足语法规则的单词序列单词：满足词法规则的字符串 基本定义字母表是一个非空的有穷集合具有整体性和可辨认性x,y的并置是由串x直接连接串y组成的x=yz，y是x的前缀 文法的定义非终结符V终结符T产生式P开始符号S句型和句子句子中都是非终结符，句型中可以有终结符 文法的分类0型文法：短语结构文法(PSG)1型文法：上下文有关文法(CSG)2型文法：上下文无关文法(CFG)，产生式的左边都是非终结符3型文法：正则文法(RG)左线性文法：A-&gt;Ba or A-&gt;a 右线性文法：A-&gt;aB or A-&gt;a 统称为正则文法判断文法：约定RG,CFG,CSG中可以含有形如A-&gt;ε的产生式，可以推出常数的是正则文法 CFG的语法树短语首先是至少推出两步，子树的最外圈。一棵子树的所有叶子自左至右排列起来形成一个相对于子树根的短语直接短语推到底的往上一层就是。仅有父子两代的一棵子树，它的所有叶子自左至右排列起来所形成的符号串句柄最左边的直接短语。一个句型的分析树中最左那棵只有父子两代的子树的所有叶子的自左至右排列素短语是一个短语，至少含有一个终结符，并且除它自身以外没有其他的素短语最左规约为规范归约，最右推导为规范推导 CFG的二义性对于任意的CFG如果存在两颗不同的语法树二义性问题无法判定但是可以找到一些充分条件，满足这些充分条件的文法就是无二义性的","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]},{"title":"编译原理第一章","slug":"编译原理第一章","date":"2018-11-21T12:21:40.000Z","updated":"2021-03-13T01:55:21.834Z","comments":true,"path":"2018/11/21/编译原理第一章/","link":"","permalink":"http://yoursite.com/2018/11/21/编译原理第一章/","excerpt":"程序设计语言机器语言汇编语言高级语言","text":"程序设计语言机器语言汇编语言高级语言 程序设计语言的翻译翻译：一种语言翻译成等价的另一种语言编译程序：高级语言编译成低级语言（特殊的翻译）将源程序翻译成可执行的目标代码。将源程序完整的转化为机器语言或者汇编语言程序，然后再处理、执行的翻译程序解释程序：一句句翻译并执行，不生成可存储的目标代码。对每次读到的语句进行解释，同时读取执行此语句需要的数据。 编译程序的生成1.T形图：用源语言到表示语言到目标语言2.自展：如何直接在一个机器上实现C语言编译器3.移植：A机上有一个C语言编译器，是否可利用此编译器实现B机上的C语言编译器？ 编译程序的总体结构","categories":[{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"ML","slug":"ML","permalink":"http://yoursite.com/categories/ML/"},{"name":"课程","slug":"课程","permalink":"http://yoursite.com/categories/课程/"},{"name":"复试","slug":"复试","permalink":"http://yoursite.com/categories/复试/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"nlp","slug":"nlp","permalink":"http://yoursite.com/tags/nlp/"},{"name":"矩阵分析","slug":"矩阵分析","permalink":"http://yoursite.com/tags/矩阵分析/"},{"name":"❤","slug":"❤","permalink":"http://yoursite.com/tags/❤/"},{"name":"游戏化思维","slug":"游戏化思维","permalink":"http://yoursite.com/tags/游戏化思维/"},{"name":"现代密码学","slug":"现代密码学","permalink":"http://yoursite.com/tags/现代密码学/"},{"name":"智能证券投资学","slug":"智能证券投资学","permalink":"http://yoursite.com/tags/智能证券投资学/"},{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/tags/算法设计与分析/"},{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"},{"name":"逻辑推理","slug":"逻辑推理","permalink":"http://yoursite.com/tags/逻辑推理/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"离散数学","slug":"离散数学","permalink":"http://yoursite.com/tags/离散数学/"},{"name":"项目管理","slug":"项目管理","permalink":"http://yoursite.com/tags/项目管理/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Javaee","slug":"Javaee","permalink":"http://yoursite.com/tags/Javaee/"}]}