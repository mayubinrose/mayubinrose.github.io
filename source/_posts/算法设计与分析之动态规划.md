---
title: 算法设计与分析之动态规划
date: 2020-03-11 10:58:56
tags: 算法设计与分析
categories: 课程
---
# 动态规划
## 例子：最短路径问题
输入：起点集合与终点集合。输出：一条从起始到终点的最短路径
蛮力算法：考察每一条，如果网络的层数为k则路径条数接近2^k
动态规划算法：多阶段决策过程，每步求解的问题是后面阶段求解问题的子问题，每一步依赖于前步骤的决策结果
![sd](/算法设计与分析之动态规划/11.png)

## 优化原则：最优子结构性质
```bash
优化函数的特点：任何最短路的子路径相对于子问题始终点最短
优化原则：一个最优决策的任何子序列本身也是相对于子序列的最优决策序列
```
![sd](/算法设计与分析之动态规划/22.png)
 <!--more--> 

## 例子：矩阵链相乘
问题：Ai为Pi-1xPi阶矩阵，确定乘法顺序，使得元素相乘的总次数最少
输入：n个矩阵的行数与列数以向量形式给出
输出：矩阵链乘法加上括号的位置
分析：基本运算次数，计算每个元素的总计乘法次数为ijk
算法分析
1.蛮力算法
加上n个括号的方法有卡特兰数级别的方法数，是一个指数级别
2.动态规划算法
子问题划分：设置最好的划分的运算次数：m[i,j]
子问题的依赖关系：最优划分最后一次相乘发生在矩阵k的位置
优化函数的递推方程：
![sd](/算法设计与分析之动态规划/33.png)
### 动态规划算法的递归实现
![sd](/算法设计与分析之动态规划/44.png)
```bash
时间复杂度分析：通过数学归纳法容易证明T(n)>=2^(n-1)
递归实现效率不高，多个子问题重复计算
```
### 动态规划算法的迭代实现
```bash
对于矩阵相乘算法的子问题的分析：长度为x的子问题有n-x个
时间复杂度分析：需要构建备忘录与标记函数。O(n^3)
```
![sd](/算法设计与分析之动态规划/66.png)
![sd](/算法设计与分析之动态规划/77.png)
两种方法的比较：迭代算法的时间复杂度比递归的小，但是消耗空间
动态规划时间复杂度：备忘录各项计算量之和加上追踪解工作量
**动态规划的要素：1.划分子问题2.定义优化函数，确定是否满足最优子结构3.列出递推方程和边界条件4.设计备忘录5.考虑是否使用标记函数6.计算时间复杂度**
## 例子：投资问题
问题：m元钱，n项投资项目，函数fi（x）表示将x投入第i个项目的效益，求使得总的效益最大的投资方案
建模：目标函数是f1(x1)+···+fn(xn)的最大值。约束条件是所有的x相加为m
**子问题的界定与计算顺序：由参数k与x界定，k为考虑对项目1到k的投资，x表示投资的总钱数不超过x**
**优化函数的递推方程：Fk(x)：x元投资给前k个项目的最大收益**![sd](/算法设计与分析之动态规划/55.png)
**备忘录和解**
![sd](/算法设计与分析之动态规划/88.png)
其中表格第二个数据表示的是投资给这个项目的钱数
**时间复杂度分析：备忘录中有m行n列，一共mn项，xk的取值有x+1种取法，计算Fk(x)项需要x+1次加法与x次比较，加法与比较的所有项求和得到w(n) =O(nm^2)**
## 例子：背包问题
问题：可以放入背包的物品有n种，每种物体的重量和价值为wi与vi，背包的最大重量限制为b，怎么样选择使得价值最大

建模：目标函数为求价值乘以个数的之和的最大值，约束条件为个数乘以重量求和的不超过b
**子问题界定与计算顺序：由参数k与y界定，k表示对于物品1到k的选择，y表示的是总重量不超过y。**
**优化函数的递推方程：**![sd](/算法设计与分析之动态规划/99.png)
```bash
对比：相比较与投资问题，这里的b为钱数m，投资项目为物品种数效益相当于价值
关键在于背包问题中有一个每一个物品都有一个重量这个条件在约束
所以如上图所示，递归方程其实是一样的，只是写法不同而已。
第一种的递推方程是一次只减少一个最后一个物品的重量，依次可以递推下去得到优化解

```
**标记函数：通过最大标号可以得出最大物品至少装了一件或者哪些没装**
![sd](/算法设计与分析之动态规划/1.png)
**实例追踪解：通过标记函数得到的最大物品，然后减去这个最大物品的重量迭代下去就可以得到每个物品的重量，然后可以得到价值**
![sd](/算法设计与分析之动态规划/2.png)
**时间复杂度分析：备忘录的计算需要nb项，每项常数时间O(nb)**
背包问题的推广：1.0-1背包，每个物品要么装要么不装，且只有一个2.多背包问题，m个背包，背包j装入的最大重量为Bj在满足所有背包的约束条件下使得物品价值最大3.二维背包问题，多个约束条件，不仅仅有重量还有体积约束
## 例子：最长公共子序列
问题：给定两个序列，求xy的最长公共子序列，要求字母出现的顺序一样的
算法：
1.蛮力算法：x的长度m，y的长度n。依次检查x的每个子序列在y中是否出现。时间复杂度分析：每个子序列O(n)时间，X有2^m个子序列，最坏情况的时间复杂度为O(n2^m)
2.动态规划：
**子问题的界定与子问题的依赖关系**
![sd](/算法设计与分析之动态规划/3.png)
满足优化原则以及子问题的重叠性
**递推方程**
![sd](/算法设计与分析之动态规划/4.png)
**标记函数**
![sd](/算法设计与分析之动态规划/5.png)
通过标记函数遇到左上则输出该数，然后向左上方移动，遇到向上或者向左移动则移动即可
**时间与空间复杂度分析：标记函数迭代次数为O(mn)次，都是O(mn)**
## 例子：黑白图像存储
问题：每个像素的灰度值都不一样，但是都是0到255的范围，如果每个像素点都按照8为存储的话总的设计空间为8n
思想：图像变位压缩
将像素点进行分类，每一类的像素点个数以及占位多少不同，所以多了一个段头11位
![sd](/算法设计与分析之动态规划/6.png)
```bash
对于方法1，一共分成三段，所以有11*3，第一段的最大15用4位存储即可，第二段最大255，用8位存储，第三段最大2，用两位存储
```
**子问题的界定与计算顺序：前边界为1，后边界为i，优化函数s[i]存储最优分段存储位数**
**算法设计：递推方程**
![sd](/算法设计与分析之动态规划/7.png)
![sd](/算法设计与分析之动态规划/8.png)
**时间复杂度分析：从后向前追踪第j段的长度所以只要O(n)**
## 例子：最大子段和
问题：给定n个数（可以有负数）的序列，求最大的前子段和
算法：
1.蛮力算法：对所有的（i，j）顺序求和然后比较求出最大的和O(n^3)
2.分治算法：将数组分成左右两半，分别计算左边的最大和，右边的最大和，跨边界的最大和，然后比较其中最大值O(nlogn)
3.动态规划
**子问题界定：前边界为1，后边界i，c[i]为A[1···i]必须包含A[i]的向前连续延申的最大子段和**
**递推方程**

![sd](/算法设计与分析之动态规划/9.png)

```bash
参与比较的数为每i个数的最大值，要么是用前i-1的数c[i-1]加上A[i]或者直接是A[i]
这里在c代码实现的过程中表示为前几项求和，如果求到求和小于0，则重新求和，每一轮比较一次最大值
```

## 最优二叉检索树
问题：集合S为排序的n个元素，将这些元素存储在一颗二叉树的结点上，查找x是否在这些数当中，如果不在确定在哪个间隙
**检索数据的平均时间**
![sd](/算法设计与分析之动态规划/10.png)
**平均比较次数的计算**
![sd](/算法设计与分析之动态规划/12.png)
**问题：给定数据集，以及每个节点或者间隙的存取概论，求一颗最优的二叉检索树**
**子问题划分以及规约**
![sd](/算法设计与分析之动态规划/13.png)
**子问题的概率求和**
![sd](/算法设计与分析之动态规划/14.png)
**优化函数的递推方程**
![sd](/算法设计与分析之动态规划/15.png)
```bash
之所以要加上w[i···j]，是因为向上延申的过程中，高度增加了1
```
**递推方程：m[ij]=min{m[i,j]k | i<=k<=j}**
![sd](/算法设计与分析之动态规划/16.png)
**时间复杂度：ij的所有组合有平方个，每种最不同的k进行运算所以O(n^3)，空间复杂度为O(n^2)**
## 序列比对
问题：给定两个序列s1,s2，通过一定的字符编辑将s1转变成s2，完成这种编辑的最少操作的个数为编辑距离
**子问题的界定与规约**
![sd](/算法设计与分析之动态规划/17.png)
**优化函数的递推方程**
![sd](/算法设计与分析之动态规划/18.png)
**时间复杂度分析：因为子问题由ij界定有O(mn)个子问题，每个子问题的计算为常数，所以为O(mn)**
```bash
动态规划的设计要点
1.引入参数界定子问题的边界，注意子问题的重叠程度
2.给出带边界参数的优化函数定义以及递推关系，找到递推关系的初值
3.判断问题是否满足优化原则
4.考虑是否使用标记函数
5.自底向上从最小的子问题开始迭代计算，计算备忘录中优化函数和标记函数的值
6.时间复杂度只要对所有的子问题（备忘录）工作量求和
7.一般使用了较多的存储空间**瓶颈**
```






