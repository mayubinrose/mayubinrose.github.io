---
layout: title
title: 符号表管理
date: 2018-12-03 20:17:33
tags: 编译原理
categories: 课程
---
# 符号表的作用
协助进行语义检查(如检查一个名字的引用和之前的声明是否相符)和中间代码生成 
在目标代码生成阶段，当需要为名字分配地址时，符号表中的信息将是地址分配的主要依据 
编译器用符号表来记录、收集和查找出现在源程序中的各种名字及其语义信息。
符号表是以名字为关键字来记录其信息的数据结构，其上支持的两个最基本操作应该是添加表项和查找表项，这两个操作必须是高效的 
 <!--more--> 
# 符号表中存放的信息
记录源程序中出现的各种名字及其属性信息是符号表的首要任务。显然同一个名字在一段程序中应该表示同一个对象，即同一个符号表中不能出现相同的名字，因此名字可以作为符号表的关键字。
## 符号表中的名字
名字字段长度固定：名字项的长度大小取决于标识符允许的最大长度，不适于标识符长度变化范围较大的语言，空间浪费 
名字字段长度可变：标识符的长度没有限制，符号表上的操作复杂而低效 
## 符号表中的属性
符号所表达的含义不同，符号表中需要存放的属性也就不同 
方法1：建立多个符号表来管理源程序中出现的各种符号，如常数表、变量表、函数表、数组表等 
问题：可能出现不同种类符号重名的问题 
方法2：建立一张共用的大表来管理各种符号，需要在符号表增设一个标志来表明符号的种属
问题：不同种类符号所需存放属性信息在数量上的差异将会造成符号表的空间浪费  
## 符号的地址属性
如果采用静态存储分配策略，则符号x绑定的地址等于静态分配的基址base加上符号x的偏移量offset 
如果采用的是栈式存储分配或堆式存储分配等动态分配策略，则符号是在程序执行过程中和地址动态绑定的。 
如栈式存储分配时，i的地址是以栈指针sp为基址加上i相对于活动记录起始地址的偏移量offset i 
**符号表中各符号的地址属性就是该符号相对于第一个符号的偏移地址**
# 符号表的组织结构
## 符号表的线性表实现
数组实现：插入n个符号、执行e次查找操作的时间复杂度为T(n, e) = O(n(n+e))  
有序数组实现：插入n个符号、执行e次查找操作的时间复杂度为T(n, e)≤ O(n+e)log n+O(n2) 
有序符号表结构只有在下面的情况下才能取得较好效果：和插入操作次数相比，符号表表项上的查找操作次数占绝对多数，即e>>n。
## 符号表的散列表实现
引入散列表不仅可以提高lookup操作的效率，同时也可以提高insert操作的效率，所以在许多实际编译器的符号表实现中均采用了散列技术
# 符号表与作用域
## 程序块结构的符号表
每个程序块建立一个符号表，程序块内的符号记录在该程序块所对应的符号表中,还要建立起这些符号表之间的联系,以刻画出符号的嵌套作用域。实现的问题：有时需要维护的符号表数量太大
## 程序块结构符号表的其他实现
将所有块的符号表放在一个大数组中，然后再引入一个程序块表来描述各程序块的符号表在大数组中的位置及其相互关系 
将符号所属程序块编号放在符号表表项中。查找某个符号的名字name时，只有当name和符号表中的名字字符串完全匹配，且符号表表项中的块编号和当前处理的块编号完全相同时才算查找成功。程序块编号可以通过在语法制导定义中的块开始处和块结束处添加适当的语义规则计算得出。
程序块满足最近嵌套原则
## C语言的符号表
一个完整的C程序由一个或多个相对独立的函数组成，函数之间的通信依靠参数传递和全局变量
全局变量和函数名的作用域是整个程序，而其余变量的作用域则是定义它们的函数
如果采取将每个函数分别编译成目标代码然后连接装配成一个可执行程序的处理方式，则每个函数中的符号经一遍处理即可，而且源程序中的多个函数是一个接一个处理的，不会出现交叉
## 小结
符号表用来存放编译器各阶段收集来的各种名字的类型和特征等有关信息，并供编译程序用于语法检查、语义检查、生成中间代码及生成目标代码等；
源程序中会出现各种各样的名字，如函数名、函数参数名、函数中的局部变量名、全局变量名、数组名、结构名、文件名等，相应的属性可以是种属、类型、地址等。
根据符号所需的属性个数和类型的不同，可以组成不同的符号表，也可以组成统一的符号表，在组成统一符号表时，需要采用恰当的组织结构，以便可以对其进行高效处理。
随着程序规模的扩大，符号名的数量会很大，因而必须关注符号表的组织和高效管理。无序线性符号表、有序线性符号表、散列表示符号表具有不同性能的组织形式。
符号表管理中必须关注到语言所规定的符号的作用域，特别是在嵌套结构的程序中，符号的作用域是分层的。
C语言符号表的管理
