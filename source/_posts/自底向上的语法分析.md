---
layout: titile
title: 自底向上的语法分析
date: 2018-11-26 17:52:00
tags: 编译原理
categories: 课程
---
# 自底向上的语法分析概述
输入串出发反复归约，最后可以得到文法的开始符号，则输入串是相应文法的一个句子。在分析的过程中，寻找当前句型最左的和某个产生式的右部相匹配的子串
 <!--more--> 
**最右推导为规范推导 最左归约为规范归约**
## 移进归约分析
一张分析表，一个输入缓冲区，一个分析栈，一个输出缓冲区
**格局**：栈+输入缓冲区剩余内容
## 优先法
思想：根据归约的先后次序为句型中相邻的文法符号规定优先关系
句柄内相邻符号同时归约，是同优先级的
句柄两端符号的优先级要高于句柄外与之相邻的符号
简单优先文法：如果各文法符号之间的优先关系互不冲突(至多存在一种优先关系)，则可识别任意句型的句柄
算符优先文法：仅对文法中可能在句型中相邻的终结符定义优先关系，并且各终结符对之间的优先关系互不冲突。
## 状态法
根据句柄的识别状态来识别句柄
1.移进归约冲突
2.归约归约冲突
# 算符优先分析法
将句型中的终结符当作算符，然后定义算符之间的某种优先关系，利用优先关系来寻找句柄进行归约
## 算符优先文法
表达式的运算次序和运算对象没有关系，而只和运算符的优先级有关系
如果文法G中不存在具有相邻非终结符的产生式，则称为算符文法。在无ε产生式的算符文法Ｇ中，如果任意一对终结符之间至多有一种优先关系，则称为算符优先文法。
## 算符优先矩阵的构造
FIRSTOP(A)={b|A+b…或者A+Bb…, b∈T, B ∈V} （最左终结符集合）
LASTOP(A)={b|A+…b或者A+…bB, b∈T, B ∈V} （最右终结符集合）
终结符的优先关系小于FIRSTOP大于LASTOP
## 算符优先分析算法
**素短语**至少包含一个终结符，除自身以外不再包含其他含终结符的短语
栈内优先级高则归约否则移进
## 优先函数
分成栈内优先函数和栈外优先函数，可能不存在对应优先关系表的优先函数，若存在也不唯一。存在的话，可以通过三个步骤构造优先函数
1.画图：a>=b 从fa画一条弧线到gb，如果a<=b，从gb画一条弧线到fa
2.数数：从一个节点出发能到达的节点(沿着线随意走的经过点，包括它自己)
3.检查：是否与原来的关系矛盾
## 算符优先分析的出错处理
语法错误：1.栈顶的终结符号和当前输入符号之间不存在任何优先关系(修改栈，输入)2.发现被归约对象但不是任何产生式的右部(继续将这些符号出栈)
# LR分析法
L:自左向右扫描输入符号R:构造最右推导的逆过程
LR文法不是二义的，二义文法一定不是LR的
## LR分析算法
句柄：非形式的，句柄是和某个产生式右部匹配的字符串，把句柄归约成产生式左部的非终结符，可以得到最右推导的逆过程的一步
举例：E->E+E|E*E|-E|(E)|id，对于id+id*id，其中一个最右推导为E->E+E->E+E*E->E+E*id->E+id*id->id+id*id。在id+id*id归约成E+id*id的过程中，最左边的id是句柄。E+id*id归约成E+E*id时，最左边的id是句柄，把E+E*id归约成E+E*E时，id是句柄。把E+E*E归约成E+E时E*E是句柄。E+E归约成E时，E+E是句柄。
前缀：如abc的前缀是a,ab,abc
活前缀：举个例子，比如E+E*E归约成E+E，句柄是E*E，那么它的活前缀就是E、E+、E+E、E+E*、E+E*E。又比如id+id*id归约成E+id*id，句柄是最左边的id，那么它的活前缀是id，因为不能超过句柄
![sds](/自底向上的语法分析/p1.png "LR分析结构图")
## LR(0)分析表的构造
项目集闭包：从一个项目出发e-可达的所有项目集合
后继项目：识别一个非终结符后进入的项目
闭包之间的转移：GO(I,X)=CLOSURE({A→αX.β| A→α.Xβ∈I}
归约归约冲突 移进归约冲突
## SLR(1)分析表的构造
***在FOLLOW集中才可以进行归约否则进行移入***只能排除不合理归约但是不能找到正确的归约
还是有移入归约冲突，归约归约冲突
## LR(1)分析表的构造
在特定位置，A的后继符集合是FOLLOW(A)的子集
[A→α.β, a]的项为LR(1)项，a为一个终结符表示在当前状态下，A后面必须紧跟终结符，称为该项的**展望符**
如何给给定的文法构造LR(1)自动机，同样的求闭包同时要把展望符也给求出来
## LALR(1)分析表的构造
合并同心项目集，会产生归约归约冲突，不会有移入归约冲突可能会推迟错误的发现
形式上与LR(1)相同，大小上与LR(0)/SLR相同，分析能力介于SLR与LR(1)之间
## 二义性文法的应用
任何一个二义性文法都不是LR的，某些二义性文法对语言的说明和实现非常有用，只要指明消除二义性的规则，还是少用
## LR分析中的出错处理
紧急方式的错误恢复：从栈顶开始退栈，直至发现在某个语法变量A上具有转移的状态S为止, A通常是主要程序结构的语法变量。丢弃零个或多个输入符号，直至找到符号a FOLLOW(A) 为止。分析器把状态goto[S，A]压进栈，并恢复正常分析

SLR(1)判断规则
方法一：画出文法的LR(0)自动机，如果没有移进--规约冲突，即shift--reduce 冲突，则该文法是SLP(1)文法
LR(1)>LALR(1)>SLR(1)>LR(0)