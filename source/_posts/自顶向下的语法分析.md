---
layout: title
title: 自顶向下的语法分析
date: 2018-11-25 14:10:07
tags: 编译原理
categories: 课程
---
# 语法分析概述
语法分析是编译程序的核心部分，其任务是检查词法分析器输出的**单词序列是否为源语言中的句子**，也就是是否符合源语言的语法规则
主要有两种方式
1.产生句子的方式：从开始符号逐步推导出单词序列，自顶向下分析（递归子程序法，预测分析法LL(1)）
2.识别句子的方式：逐步将构成程序的单词序列归约成文法的开始符号，自底向上分析（算符优先分析法，LR(0),SLR(1),LR(1),LALR(1)）
 <!--more--> 
这两种方式都是自左向右地扫描输入单词序列，针对输入单词序列建立一颗语法分析树
语法分析处理时的恢复策略：紧急方式恢复策略（丢弃直到发现同步记号：; end）短语级恢复策略（对剩余输入做局部纠正）
# 自顶向下的语法分析面临的问题与文法的改造
## 面临的问题
1.二义性问题
解决方法：改造文法，引入新的文法变量或者根据优先级关系，保证高优先级运算符优先的原则
2.回溯问题：多个候选式
3.左递归引起的无穷推导问题
## 对上下文无关文法的改造
1.消除二义性
2.消除左递归：A→Aα|β替换为A→βA'     A' →αA' |ε 间接左递归只要采用代入法变为直接左递归就可以
3.提取左因子：将公共前缀提取出来
解决以上三个问题才能实现确定的自顶向下分析
## LL(1)文法
FIRST(X):可以从X推导出的所有串首终结符构成的的集合，如果可以推出空串
FIRST(α)={a|α     aβ，aT，β(V∪T)*}
计算FIRST集：产生式右部的第一个是终结符，直接加，是非终结符，将该非终结符的FIRST集加入到产生式左部的FIRST集中。不断循环调用直到没有新的可以加入。
FOLLOW(A):可能在某个句型中紧跟在A后边的终结符的集合，如果A是句型的最右符号，则将结束符#加入到FOLLOWa(A)中。
计算FOLLOW(A)集合：首先将#放入FOLLOW(S)中，因为S是开始符号，#输入右端的结束标记。计算的符号的后面跟着终结符则直接加入，产生式左部的FOLLOW集合可以在产生式右部的最后一个非终结符的FOLLOW集，不断循环直到没有新的可以加入。
SELECT(产生式)：若产生式右部不为空，则为产生式右部的第一个非终结符的FIRST集，或产生式右部的第一个终结符，若右部为空，则为产生式左部的FOLLOW集。
**相同产生式左部的SELECT集不相交则为LL(1)文法**
# 预测分析法
该方法是一种高效的自顶向下的分析方法。预测分析程序采用该方法实现语法分析，所以叫预测分析器，又可以在无附加条件时对LL(1)文法实现确定的自顶向下分析，有时也叫LL(1)分析器。
## 预测分析器的构成
![q](/自顶向下的语法分析/p1.png)
## 预测分析表的构造
分析栈中一开始存放栈底符号#和文法的开始符号，然后根据栈顶符号A和读入的符号查看分析表M决定执行相应的动作
计算方法：计算FIRST和FOLLOW集合进行填表操作
## 预测分析中的错误处理
错误有：栈顶终结符号和下一个输入符号不匹配，栈顶是语法变量A，a是下一个输入符号M[A,a]是空白表项  紧急方式错误恢复策略：发现错误时跳过一些输入符号，直到下一个语法成分包含的第一个符号为止（同步记号）
使用方法：
M[A,a]表项是synch，表明a属于follow(A)，弹出A，继续执行下面的分析
1.如果表项M[A, a]为空，则跳过输入符号a；
2.如果表项是synch，则弹出栈顶的语法变量并试图恢复分析；
3.如果栈顶的记号与输入符号不匹配，则从栈顶弹出该记号
# 递归下降分析法
## 基本思想
为每个语法变量编写一个处理子程序，终结符直接匹配，非终结符就调用处理子程序
## 语法图和递归子程序法
![sss](/自顶向下的语法分析/p2.png)
## 语法图的化简与实现
左右因子提取和消除尾递归
![sss](/自顶向下的语法分析/p3.png)


