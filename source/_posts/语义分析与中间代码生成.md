---
layout: title
title: 语义分析与中间代码生成
date: 2018-11-29 15:17:55
tags: 编译原理
categories: 课程
---
# 中间代码的形式
抽象语法树，逆波兰表示，三地址码，DAG图
## 逆波兰表示
后缀表示法：运算顺序就是运算符出现的顺序。中缀表达式a:=a*b+c*d，前缀表达式：:=a+*ab*cd，后缀表达式：abc*bd*+:=
 <!--more--> 
## 三地址码
代码的每条指令最多只能包含三个地址，即两个操作地址和一个结果地址。三地址码中地址的形式：名字、常量、编译器生成的临时变量。
常用的实现方式有三元式和四元式
![sd1](/语义分析与中间代码生成/p1.png "四元式")
![sd2](/语义分析与中间代码生成/p2.png "三元式")
## 图表示
**无回路有向图(DAG)**可以**消除公共子表达式**在DAG中代表公共子表达式的节点具有多个父节点
![sd3](/语义分析与中间代码生成/p3.png "图表示")
## 声明语句的翻译
声明语句的作用是为程序中用到的变量或常量名指定类型，而类型的作用主要体现在1.类型检查：是否符合规则2.辅助翻译：确定存储空间
### 类型表达式
1．基本类型是类型表达式。Boolean、char、integer、real、void
2．类型名是类型表达式
3．将类型构造符array应用于数字和类型表达式所形成的表达式是类型表达式
4．如果T1和T2是类型表达式，则其笛卡尔乘积T1×T2也是类型表达式。
5．类型构造符record作用于由域名和域类型所形成的表达式也是类型表达式。
6．如果T是类型表达式，那么pointer(T)也是类型表达式，表示“指向类型为T的对象的指针”
## 类型等价
结构等价：下面的条件之一成立：1.T1和T2是相同的基本类型；2.T1和T2是将同一类型构造符应用于结构等价的类型上形成的；3.T1是表示T2的类型名。如果将类型名看作只代表他们自己的话，前两个条件将导致类型表达式的**名字等价**两个类型表达式名字等价当且仅当他们完全相同
![sd4](/语义分析与中间代码生成/p4.png "等价实例")
## 声明语句的文法
![sd5](/语义分析与中间代码生成/p5.png "声明语句的文法")
## 过程内声明语句的翻译
声明语句的翻译就是在符号表中为每个局部名字创建一个表项，同时维护该名字的类型及相对地址等信息
# 赋值语句的翻译
辅助子程序：gencode(code) ：产生一条中间代码 newtemp：产生新的临时变量 lookup：检查符号表中是否出现某名字，如果有，则返回指向该表项的指针
语义属性设置：中间代码序列：code 地址：addr 下一条四元式序号：nextquad
## 简单赋值语句的翻译
主要任务：生成对表达式求值的三地址码
![sd6](/语义分析与中间代码生成/p6.png "简单赋值语句的翻译")
## 数组元素的寻址
Elist.array，用来记录指向符号表中相应数组名字表项的指针。
Elist.ndim，用来记录Elist中下标表达式的个数，即Elist的维数。
Elist.addr，用来临时存放Elist的下标表达式计算出来的值。
limit(array, j)，返回nj，即由array指示的数组的第j维的维长
![sd7](/语义分析与中间代码生成/p7.png "数组元素的寻址计算")
## 带有数组引用的赋值语句的翻译
![sd8](/语义分析与中间代码生成/p9.png "赋值语句的翻译")
![sd9](/语义分析与中间代码生成/p8.png "赋值语句的翻译")
![sd10](/语义分析与中间代码生成/p10.png "例：A为一个10*20的整型数组")
# 类型检查
发现程序错误的能力，确定这些类型表达式是否符合一定的规则，这些规则的集合通常称为源程序的类型系统
## 类型检查的规则
**类型综合**：从子表达式的类型确定表达式的类型，要求名字在引用之前必须先进行声明，典型的逻辑规则：if f的类型为s→t and x的类型为s then 表达式f(x)的类型为t 
**类型推断**：根据语言的使用方式来确定其类型，通常用于从函数体推断函数类型，逻辑规则：if f(x)是一个表达式，对于其赋值情况和参数计算方式，then  f具有类型α→β (两个类型变量α和β) and x具有类型α 
## 类型转换
![sd11](/语义分析与中间代码生成/p11.png "类型转换实例")
# 控制结构的翻译
控制语句的翻译与布尔表达式的翻译有关，布尔表达式的两个作用：计算逻辑值和改变控制流程
## 布尔表达式的翻译
**not>and>or**
![sd12](/语义分析与中间代码生成/p12.png "实例")
## 常见控制结构的翻译
![sd13](/语义分析与中间代码生成/p13.png "常见控制结构的翻译")
## 布尔表达式的控制流翻译
![sd14](/语义分析与中间代码生成/p14.png "布尔表达式的控制流翻译")
## 混合模式的布尔表达式翻译
引入语义属性：E.type:  arith 或者bool E.true, E.false：E为布尔表达式 E.addr：E为算术表达式
![sd14](/语义分析与中间代码生成/p15.png "混合模式的布尔表达式翻译")
# 回填
在生成跳转语句时可能不知道控制要转向的指令的标号，一种解决方法是先生成暂时没有指定目标标号的一系列跳转指令，每个这样的指令都将放在一个跳转指令链表中，指令标号要等到目标标号确认下来才能填入
翻译模式用到如下三个函数：
1．makelist(i)：创建一个只包含i的新表，i是四元式数组的一个索引(下标)，或者说i是四元式代码序列的一个标号。 
2．merge(p1, p2)：合并由指针p1和p2指向的两个表并且返回一个指向合并后的表的指针。 
3．backpatch(p，i)：把i作为目标标号回填到p所指向的表中的每一个转移指令中去。
此处的“表”都是为“回填”所准备的链表
## 布尔表达式的回填式翻译
![sd14](/语义分析与中间代码生成/p16.png "混合模式的布尔表达式翻译")
## 常见控制结构的回填式翻译
![sd14](/语义分析与中间代码生成/p17.png "常见控制结构的回填式翻译")
# switch语句的翻译
# 过程调用和返回语句的翻译
# 输入输出语句的翻译