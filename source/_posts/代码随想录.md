---
layout: title
title: 代码随想录
date: 2021-09-23 17:02:52
tags: [算法题,开发岗]
top: 99 
categories: 开发岗
---
# 数组
## 二分查找
整体的插入方法分为两类，一类是while(l < r) ，这种情况的子情况如果l = mid + 1 , r = mid ,此时计算mid = (l + r) >> 1，子情况2 l = mid , r = mid - 1, 此时计算mid = (l + r + 1) >> 1，循环结束的时候l == r。 针对区间[l , r) 。
第二类while(l <= r)，此时 l = mid + 1 , r = mid - 1 , 计算mid = (l + r) >> 1，循环结束的时候l > r ，针对区间[l , r]
第一类的区间
<!--more-->
### Leecode35 搜索插入位置
```c++
// 方法一
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int l = 0 , r = n - 1;
        while( l < r){
            int mid = (l + r + 1) >> 1;
            if(nums[mid] < target) {
                l = mid ;
            }else if (nums[mid] > target) {
                r = mid - 1 ;
            }
            else{
                return mid ;
            }
        }
        if(nums[l] < target )return l + 1;
        return l ;
    }
};
// 方法二
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l = 0 ,r = nums.size() - 1;
        while(l <= r ){
            int mid = (l + r) >> 1;
            if(nums[mid] < target){
                l = mid + 1;
            }else if(nums[mid] > target){
                r = mid -1;
            }
            else{
                return mid;
            }
        }
        return l  ; // return  r - 1;
    }
};
```
### Leecode34 在排序数组中查找元素的第一个和最后一个位置
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(!nums.size() ) return {-1 , -1};
        int left = findLeft(nums, target);
        int right = findRight(nums ,target);
        // 如果找到的指向最左边和最右边的下标都越界 
        if(left == nums.size() || right == -1 )return {-1 , -1};
        // 如果没有当前target
        if(nums[left] != target || nums[right] != target) return {-1 , -1}; 
        return {left, right};
    }   
    int findLeft(vector<int> & nums, int target){
        int n  = nums.size();
        int  l = 0 , r = n - 1;
        while(l <= r){
            int mid = (l + r) >> 1;
            if(nums[mid] < target){
                // 等于mid l 也往右边走
                l = mid + 1;
            }else if(nums[mid] >= target){
                r = mid - 1;
            }
        }
        // 最后返回的l指向最左边
        return l;
    }
    int findRight(vector<int> & nums, int target){
        int n  = nums.size();
        int  l = 0 , r = n - 1;
        while(l <= r){
            int mid = (l + r) >> 1;
            if(nums[mid] <= target){
                // 等于mid l 也往右边走
                l = mid + 1;
            }else if(nums[mid] > target){
                r = mid - 1;
            }
        }
        //最后返回的r指向最右边的位置
        return r;
    }
};
```
## 移除元素
一般采用的方法有暴力解法或者双指针方法
### Leecode844 比较含有空格的字符串
```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        return bulid(s) == bulid(t);
    }
    string bulid(string s){
        int n = s.size();
        string res = "";
        for(auto c : s){
            if(c != '#'){
                res += c;
            }else{
                if(!res.empty()){
                    res.pop_back();
                }
            }
        }
        return res;
    }
};
```
### 排序算法
```c++
// 插入排序
 for(int i = 1 ; i < n ; i ++){
    int cur = nums[i] *nums[i];
    for(j = i - 1 ; j >= 0; j -- ){
        if(cur < res[j]){
            res[j + 1] = res[j];
        }else{
            cout<< j << ' ';
            break;
        }
    }
    res[j + 1]  = cur;
}
// 冒泡排序
int flag = 1;
for(int i = 0 ; i < n && flag ; i ++){
    flag = 0 ;
    for(int j = 0 ; j< n - i - 1; j ++){
        if(res[j + 1] < res[j]){
            flag = 1;
            int temp = res[j+1];
            res[j + 1] = res[j];
            res[j] = temp;
        }
    }
}
// 快速排序
// Patition 将所有小于第一个数字的数字都放在左边，所有大于第一个数字数都放在右边，并且第一个数字当前的下标
    int Patition(int* a , int low , int high){
        int temp  = a[low] , pivoty = a[low];
        while(low < high){
            while(low < high && a[high] >= pivoty) high -- ;
            a[low ] = a[high];
            while(low < high && a[low] <= pivoty) low++;
            a[high] = a[low];
        }
        a[low] =temp;
        return low;
    }
    void QuickSort(int* a , int low , int high){
        int p ;
        if(low < high){
            p = Patition(a , low , high);
            QuickSort(a , low , p - 1);
            QuickSort(a , p + 1, high);
        }
    }
```
## 长度最小的子数组
### Leecode904 水果成篮
```c++
class Solution {
public:
// 连续的一段数字中不同的数字只有两个，返回值为这一段连续的数字的长度的最大值
    int totalFruit(vector<int>& nums) {
        int n = nums.size();
        // 存储数字是否出现过
        unordered_map<int , int> map;
        int res = 0 ;
        int start = 0 , end = 0 ;
        while(end < n ){
            map[nums[end]] ++ ;
            if(map.size() > 2){
                map[nums[start]] -- ;
                // 关键在当map中开始指针的数字不存在的时候，erase当前键值对
                // erase(begin(),end())，erase(key)，erase(pos)，返回值为删除的个数，返回的迭代器指向下一个
                if(map[nums[start]] == 0) map.erase(nums[start]);
                start++;
                res = max(res , end - start + 1);
            }else{
                res = max(res , end - start + 1);
            }
            end ++ ;
        }
        return res;
    }
};
```
### Leecode76 最小覆盖子串
```c++
class Solution {
public:
// s覆盖t的最小字符串长度需要满足
// 1.s需要覆盖t的所有字符 2.t中出现多次的也要进行覆盖
    string minWindow(string s, string t) {
        int m = s.size();
        int n = t.size();
        string res = "";
        if(n > m )return res;
        // 这一题的关键是用了两个哈希表 一个哈希表存储了t中的元素出现的次数，另一个用来存储s中的各个字符出现的次数，并且用一个cnt来存储已经覆盖了t中几个数字
        int cnt = 0;
        unordered_map<char , int > map , hash;
        for(auto c:t) map[c] ++ ;
        int start = 0 , end = 0;
        while(end < m){
            hash[s[end]] ++;
            if(hash[s[end]] <= map[s[end]]) cnt ++ ;
            // 当start处的字符出现的次数比需要出现的字符的次数要多的话，我们可以缩减开始指针，直到与需要的次数相同就可以
            while(hash[s[start]] > map[s[start]]){
                hash[s[start ++ ]]--;                
            }
            if(cnt == n){
                if(res.empty() || end - start + 1 < res.size()){
                    res = s.substr(start , end - start + 1);
                }
            }
            end++;
        }
        return res;
    }
};
```
## 螺旋矩阵
```c++
class Solution {
public:
    vector<vector<int>> res;
    int dx[4] = {0 , 1 , 0 , -1 };
    int dy[4] = {1 , 0 , -1 , 0 };
    int count = 1;
    int d = 0 ;
    vector<vector<int>> generateMatrix(int n) {
        res = vector(n , vector<int>(n , 0));
        if(!n) return res;
        dfs(n, 0 ,0 );
        return res;
    }
    void dfs(int n , int x , int y){
        if(count == n * n  + 1)return ;
        res[x][y] = count ++;
        int a = dx[d] + x;
        int b = dy[d] + y;
        if(a < 0 || a == n  || b < 0 || b == n || res[a][b]){
            d = (d + 1) % 4;
            a = dx[d] + x;
            b = dy[d] + y;
        }
        x = a ; 
        y = b;
        dfs(n , x, y);
    }
};
```
# 链表
### Leecode707 设计链表
```c++
class MyLinkedList {
public:
    struct LinkedNode{
        int val ; 
        LinkedNode * next;
        LinkedNode(int x):val(x), next(NULL){};
    };
    
    MyLinkedList() {
        dummy  = new LinkedNode(-1);
        size = 0 ;
    }
    
    int get(int index) {
        if(index > (size - 1) || index < 0 )return -1;
        auto  p = dummy->next;
        for(int i = 0 ; i < index ; i  ++){
            p = p ->next;
        }
        return p ->val;
    }
    
    void addAtHead(int val) {
        LinkedNode* cur = new LinkedNode(val);
        cur->next = dummy->next;
        dummy->next = cur;
        size++;
    }
    
    void addAtTail(int val) {
        LinkedNode* cur = new LinkedNode(val);
        auto p = dummy;
        while(p->next){
            p = p ->next;
        }
        p->next = cur;
        size++;
    }
    void addAtIndex(int index, int val) {
        if(index > size) return ;
        LinkedNode* cur = new LinkedNode(val);
        auto p = dummy;
        while(index--){
            p = p ->next;
        }
        cur->next = p ->next;
        p->next = cur;
        size ++ ;
    }
    void deleteAtIndex(int index) {
        if(index >= size || index < 0 )return ;
        auto q = dummy;
        while(index -- ){
            q = q->next;
        }
        // 找到q是要删除的节点的前面一个
        auto temp = q ->next;
        q->next = q->next->next;
        delete temp;
        size -- ;
    }
private:
    LinkedNode* dummy ; 
    int size;
};
```
# 哈希表
## 有效的字母异位词
### Leecode438 找到字符串中所有字母异位词
```c++
class Solution {
public:
   bool compare(int*a , int *b){
       for(int i = 0 ; i<26 ; i ++){
           if(a[i] != b[i]) return false;
       }
       return true;
   }
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        int n = s.size();
        int m = p.size();
        int p_st[26] = {0};
        int s_st[26] = {0};
        if(p.size() > s.size()) return res;
        for(int i = 0 ; i< p.size() ; i ++){
            p_st[p[i] - 'a'] ++ ;
            s_st[s[i] - 'a'] ++ ;
        }
        if(compare(p_st,s_st)) res.push_back(0);
        int end = m; 
        int start = 0;
        while(end < s.size()){
            s_st[s[start] - 'a' ] -= 1;
            s_st[s[end] - 'a'] += 1;
            end++;
            start ++ ;
            if(compare(p_st,s_st)) res.push_back(start);
        }
        return res;
    }
};
```
### Leecode202 快乐数
```c++
class Solution {
public:
    int get(int n){
        int res = 0 ;
        while(n){
            res += (n % 10) * (n % 10);
            n /= 10;
        }
        return res;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        int sum ;
        while(1){
            sum = get(n);
            if(sum == 1 ) return true;
            if(set.find(sum) != set.end()) break;
            else{
                set.insert(sum);
            }
            n = sum ;
        }
        return false;
    }
};
```
# 栈与队列
## 栈实现队列与队列实现栈
### Leecode225 队列实现栈
```c++
        class MyStack {
public:
// 每次入队列的时候先将主队列的内容放到辅助队列中，然后添加元素进入主，最后将辅助的队列的内容加入到主
    queue<int> q1;
    queue<int> q2;
    MyStack() {

    }
    
    void push(int x) {
        while(!q1.empty()){
            int top = q1.front();
            q1.pop();
            q2.push(top);
        }
        q1.push(x);
        while(!q2.empty()){
            int top = q2.front();
            q2.pop();
            q1.push(top);
        }
    }
    
    int pop() {
        int top = q1.front();
        q1.pop();
        return top;
    }
    
    int top() {
        return q1.front();
    }
    
    bool empty() {
        if(q1.empty())return true;
        return false;
    }
};
```
