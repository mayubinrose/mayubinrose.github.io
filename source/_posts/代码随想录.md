---
layout: title
title: 代码随想录
date: 2021-09-23 17:02:52
tags: [算法题,开发岗]
top: 99 
categories: 开发岗
---
# 数组
## 二分查找
整体的插入方法分为两类，一类是while(l < r) ，这种情况的子情况如果l = mid + 1 , r = mid ,此时计算mid = (l + r) >> 1，子情况2 l = mid , r = mid - 1, 此时计算mid = (l + r + 1) >> 1，循环结束的时候l == r。 针对区间[l , r) 。
第二类while(l <= r)，此时 l = mid + 1 , r = mid - 1 , 计算mid = (l + r) >> 1，循环结束的时候l > r ，针对区间[l , r]
第一类的区间
<!--more-->
### Leecode35 搜索插入位置
```c++
// 方法一
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int l = 0 , r = n - 1;
        while( l < r){
            int mid = (l + r + 1) >> 1;
            if(nums[mid] < target) {
                l = mid ;
            }else if (nums[mid] > target) {
                r = mid - 1 ;
            }
            else{
                return mid ;
            }
        }
        if(nums[l] < target )return l + 1;
        return l ;
    }
};
// 方法二
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l = 0 ,r = nums.size() - 1;
        while(l <= r ){
            int mid = (l + r) >> 1;
            if(nums[mid] < target){
                l = mid + 1;
            }else if(nums[mid] > target){
                r = mid -1;
            }
            else{
                return mid;
            }
        }
        return l  ; // return  r - 1;
    }
};
```
### Leecode34 在排序数组中查找元素的第一个和最后一个位置
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(!nums.size() ) return {-1 , -1};
        int left = findLeft(nums, target);
        int right = findRight(nums ,target);
        // 如果找到的指向最左边和最右边的下标都越界 
        if(left == nums.size() || right == -1 )return {-1 , -1};
        // 如果没有当前target
        if(nums[left] != target || nums[right] != target) return {-1 , -1}; 
        return {left, right};
    }   
    int findLeft(vector<int> & nums, int target){
        int n  = nums.size();
        int  l = 0 , r = n - 1;
        while(l <= r){
            int mid = (l + r) >> 1;
            if(nums[mid] < target){
                // 等于mid l 也往右边走
                l = mid + 1;
            }else if(nums[mid] >= target){
                r = mid - 1;
            }
        }
        // 最后返回的l指向最左边
        return l;
    }
    int findRight(vector<int> & nums, int target){
        int n  = nums.size();
        int  l = 0 , r = n - 1;
        while(l <= r){
            int mid = (l + r) >> 1;
            if(nums[mid] <= target){
                // 等于mid l 也往右边走
                l = mid + 1;
            }else if(nums[mid] > target){
                r = mid - 1;
            }
        }
        //最后返回的r指向最右边的位置
        return r;
    }
};
```
## 移除元素
一般采用的方法有暴力解法或者双指针方法
### Leecode844 比较含有空格的字符串
```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        return bulid(s) == bulid(t);
    }
    string bulid(string s){
        int n = s.size();
        string res = "";
        for(auto c : s){
            if(c != '#'){
                res += c;
            }else{
                if(!res.empty()){
                    res.pop_back();
                }
            }
        }
        return res;
    }
};
```
### 排序算法
```c++
// 插入排序
 for(int i = 1 ; i < n ; i ++){
    int cur = nums[i] *nums[i];
    for(j = i - 1 ; j >= 0; j -- ){
        if(cur < res[j]){
            res[j + 1] = res[j];
        }else{
            cout<< j << ' ';
            break;
        }
    }
    res[j + 1]  = cur;
}
// 冒泡排序
int flag = 1;
for(int i = 0 ; i < n && flag ; i ++){
    flag = 0 ;
    for(int j = 0 ; j< n - i - 1; j ++){
        if(res[j + 1] < res[j]){
            flag = 1;
            int temp = res[j+1];
            res[j + 1] = res[j];
            res[j] = temp;
        }
    }
}
```